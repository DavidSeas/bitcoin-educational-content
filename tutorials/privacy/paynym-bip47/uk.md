---
name: BIP47 - PayNym

description: Як працюють PayNyms
---
***ПОПЕРЕДЖЕННЯ:** Після арешту засновників Samourai Wallet та конфіскації їхніх серверів 24 квітня, додаток більше не може використовуватися користувачами, які не мають власного Dojo. BIP47 залишається доступним у Sparrow Wallet для всіх користувачів і **в Samourai Wallet лише для користувачів, які мають Dojo**.*

_Ми уважно слідкуємо за розвитком цієї справи, а також за розвитком пов'язаних інструментів. Будьте впевнені, що ми оновимо цей навчальний посібник, як тільки з'явиться нова інформація._

_Цей навчальний посібник надається лише для освітніх та інформаційних цілей. Ми не підтримуємо або не заохочуємо використання цих інструментів для злочинних цілей. Кожен користувач несе відповідальність за дотримання законів у своїй юрисдикції_

---

> "Він занадто великий," - говорили всі, а індичок, який народився з шпорами і думав, що він імператор, надувся, як корабель з усіма вітрилами, і з великою люттю пішов прямо на нього, його очі були червоні, як вогонь. Бідний маленький каченя не знав, чи стояти на місці, чи тікати, і було дуже нещасливим, тому що його зневажали всі качки на подвір'ї.

![BIP47, ілюстрація до казки про потворне каченя](assets/1.webp)

Однією з найсуттєвіших проблем протоколу Bitcoin є повторне використання адрес. Прозорість і розподіленість мережі роблять цю практику небезпечною для конфіденційності користувачів. Щоб уникнути проблем, пов'язаних з цим, рекомендується використовувати нову порожню адресу для кожного нового вхідного платежу до гаманця, що може бути складно досягти в деяких випадках.

Цей компроміс є старим, як і White Paper. Сатоші вже попереджав нас про цей ризик у своїй роботі, опублікованій наприкінці 2008 року:

> "Як додатковий захисний бар'єр, для кожної транзакції слід використовувати нову пару ключів, щоб вони не були пов'язані з одним власником."

Існує багато рішень для отримання кількох платежів без повторного використання адреси. Кожне з них має свої компроміси та недоліки. Серед усіх цих рішень є [BIP47](https://github.com/bitcoin/bips/blob/master/bip-0047.mediawiki), пропозиція, розроблена Justus Ranvier і опублікована в 2015 році, яка дозволяє генерувати повторно використовувані коди платежів. Її мета - дозволити здійснювати кілька транзакцій одній і тій же особі без повторного використання адреси.

Спочатку ця пропозиція зустріла зневагу з боку частини спільноти, і вона ніколи не була додана до Bitcoin Core. Однак, деяке програмне забезпечення все ж вирішило впровадити її самостійно. Наприклад, Samourai Wallet розробив власну реалізацію BIP47: PayNym. Сьогодні ця реалізація доступна в Samourai Wallet для смартфонів, а також на [Sparrow Wallet](https://sparrowwallet.com/) для ПК.

З часом Samourai запрограмував нові функції, безпосередньо пов'язані з PayNym. Тепер існує цілий екосистема інструментів, доступних для оптимізації конфіденційності користувачів на основі PayNym та BIP47.
У цій статті ви дізнаєтеся про принцип BIP47 та PayNym, механізми цих протоколів та практичні застосування, що випливають з них. Я розгляну лише першу версію BIP47, яка зараз використовується для PayNym, але версії 2, 3 та 4 працюють практично однаково.
Єдина значна відмінність полягає у транзакції повідомлення. Версія 1 використовує просту адресу з OP_RETURN для повідомлення, версія 2 використовує скрипт мультипідпису (bloom-multisig) з OP_RETURN, а версії 3 та 4 просто використовують скрипт мультипідпису (cfilter-multisig). Таким чином, механізми, обговорені в цій статті, включаючи вивчені криптографічні методи, застосовні до всіх чотирьох версій. На сьогоднішній день реалізація PayNym у Samourai Wallet та Sparrow використовує першу версію BIP47.

## Підсумок:

1- Проблема повторного використання адрес.

2- Принципи BIP47 та PayNym.

3- Посібники: Використання PayNym.

- Створення транзакції BIP47 з Samourai Wallet.
- Створення транзакції BIP47 з Sparrow Wallet.

4- Механізм роботи BIP47.

- Повторно використовуваний платіжний код.
- Криптографічний метод: обмін ключами Діффі-Хеллмана, заснований на еліптичних кривих (ECDH).
- Транзакція повідомлення.
- Створення транзакції повідомлення.
- Отримання транзакції повідомлення.
- Платіжна транзакція BIP47.
- Отримання платежу BIP47 та виведення приватного ключа.
- Повернення платежу BIP47.

5- Похідні використання PayNym.

6- Моя особиста думка про BIP47.

## Проблема повторного використання адрес.

Адреса для отримання використовується для отримання біткойнів. Вона генерується з публічного ключа шляхом його хешування та застосування специфічного формату. Таким чином, вона дозволяє створити нову умову витрати на монеті, щоб змінити її власника.

> Щоб дізнатися більше про генерацію адреси для отримання, я рекомендую прочитати останню частину цієї статті: Bitcoin Wallet - уривок з [ebook Bitcoin Démocratisé 2](https://www.pandul.fr/post/le-portefeuille-bitcoin-extrait-ebook-bitcoin-d%C3%A9mocratis%C3%A9-2#viewer-epio7).

Крім того, ви, ймовірно, вже чули від знаючого біткойнера, що адреси для отримання призначені для одноразового використання, і що ви повинні генерувати нову для кожного нового вхідного платежу на ваш гаманець. Добре, але чому?
Фундаментально, повторне використання адреси безпосередньо не загрожує вашим коштам. Використання криптографії на еліптичних кривих дозволяє вам довести мережі, що ви володієте приватним ключем, не розкриваючи цей ключ. Таким чином, ви можете заблокувати кілька різних UTXO (невитрачені вихідні транзакції) на тій самій адресі та витрачати їх у різний час. Якщо ви не розкриєте приватний ключ, асоційований з цією адресою, ніхто не зможе отримати доступ до ваших коштів. Проблема з повторним використанням адреси більше пов'язана з приватністю.

Як зазначено в інтродукції, прозорість та розподіл мережі Bitcoin означає, що будь-який користувач з доступом до вузла може спостерігати за транзакціями платіжної системи. В результаті вони можуть бачити різні баланси адрес. Тоді Сатоші Накамото згадав про можливість генерації нових пар ключів, а отже, нових адрес, для кожного нового вхідного платежу на гаманець. Метою було б мати додатковий брандмауер у випадку асоціації між ідентичністю користувача та однією з їхніх пар ключів.

Сьогодні, з наявністю компаній аналізу ланцюгів та розвитком KYC (Know Your Customer), використання пустих адрес більше не є додатковим брандмауером, а обов'язком для будь-кого, хто хоч трохи піклується про свою приватність.

Прагнення до приватності не є комфортом або фантазією максималістів Bitcoin. Це конкретний параметр, який безпосередньо впливає на вашу особисту безпеку та безпеку ваших коштів. Щоб допомогти вам зрозуміти це, ось дуже конкретний приклад:
- Боб купує Біткоїн через Dollar Cost Averaging (DCA), що означає, що він придбаває невелику кількість Біткоїну на регулярній основі, щоб усереднити свою ціну входу. Боб систематично відправляє придбані кошти на одну й ту саму адресу отримання. Він купує 0.01 Біткоїна кожного тижня і відправляє його на цю ж адресу. Після двох років Боб накопичив цілий Біткоїн на цій адресі.
- Пекар на розі приймає платежі в Біткоїнах. Зрадівши можливості витратити Біткоїн, Боб йде купити свою багету в сатоші. Для оплати він використовує кошти, заблоковані на його адресі. Тепер його пекар знає, що він володіє Біткоїном. Ця значна сума може привернути заздрість, і Боб потенційно ризикує фізичною атакою в майбутньому.

Повторне використання адреси дозволяє спостерігачу створити незаперечний зв'язок між вашими різними UTXO та іноді між вашою особистістю та всім вашим гаманцем.
Саме тому більшість програмного забезпечення для Біткоїн-гаманців автоматично генерує нову адресу отримання, коли ви натискаєте кнопку "Отримати". Для звичайних користувачів звикнути використовувати нові адреси не є великою незручністю. Однак для онлайн-бізнесу, біржі або кампанії збору пожертв це обмеження може швидко стати некерованим.
Існує багато рішень для цих організацій. Кожне з них має свої переваги та недоліки, але на сьогоднішній день, як ми побачимо пізніше, BIP47 дійсно виділяється серед інших.

Ця проблема повторного використання адреси далеко не незначна в Біткоїні. Як ви можете побачити на графіку нижче, взятому з вебсайту oxt.me, загальний рівень повторного використання адреси користувачами Біткоїна наразі становить 52%:
Графік з OXT.me, що показує еволюцію загального рівня повторного використання адрес на мережі Біткоїна.

![зображення](assets/2.webp)

Кредит: OXT

Більшість цих повторних використань походять від бірж, які з міркувань ефективності та зручності багато разів використовують одну й ту саму адресу. На сьогоднішній день BIP47 був би найкращим рішенням для подолання цього явища серед бірж. Це допомогло б знизити загальний рівень повторного використання адрес без створення надмірних труднощів для цих суб'єктів.

Цей глобальний захід на всій мережі є особливо актуальним у цьому випадку. Дійсно, повторне використання адреси є проблемою не тільки для особи, яка займається цією практикою, але й для будь-кого, хто здійснює транзакції з ними. Втрата конфіденційності в Біткоїні діє як вірус, поширюючись від користувача до користувача. Вивчення глобального заходу щодо всіх транзакцій у мережі дозволяє нам зрозуміти масштаб цього явища.

## Принципи BIP47 та PayNym.

BIP47 має на меті надати простий спосіб отримання кількох платежів без повторного використання адреси. Його робота базується на використанні повторно використовуваного платіжного коду.

Таким чином, кілька відправників можуть надсилати кілька платежів на один повторно використовуваний платіжний код іншого користувача, без необхідності для отримувача надавати нову порожню адресу для кожної нової транзакції.

Користувач може вільно ділитися своїм платіжним кодом (у соціальних мережах, на своєму вебсайті...) без ризику втрати конфіденційності, на відміну від звичайної адреси отримання або публічного ключа.
Для здійснення обміну обидва користувачі повинні мати Біткоїн-гаманець з реалізацією BIP47, такий як PayNym у Samourai Wallet або Sparrow Wallet. Асоціація платіжних кодів двох користувачів створить між ними секретний канал. Для належного встановлення цього каналу відправник повинен здійснити транзакцію на блокчейні Біткоїна: повідомлення транзакції (я розповім про це детальніше пізніше).

Асоціація платіжних кодів двох користувачів генерує спільні секрети, які, в свою чергу, генерують велику кількість унікальних адрес отримання Біткоїна (точно 2^32). Таким чином, насправді, платіж за BIP47 не надсилається на платіжний код, а на зовсім звичайні адреси, похідні від платіжних кодів залучених сторін.
Код оплати виступає як віртуальний ідентифікатор, отриманий з початкового коду гаманця. У структурі похідної HD гаманця, код оплати розташований на глибині 3, на рівні облікового запису гаманця.
![image](assets/3.webp)

Його мета похідності позначена як 47' (0x8000002F) з посиланням на BIP47. Наприклад, шлях похідності для повторно використовуваного коду оплати буде:

> m/47'/0'/0'/

Щоб дати вам уявлення про те, як виглядає код оплати, ось мій:

> PM8TJSBiQmNQDwTogMAbyqJe2PE2kQXjtgh88MRTxsrnHC8zpEtJ8j7Aj628oUFk8X6P5rJ7P5qDudE4Hwq9JXSRzGcZJbdJAjM9oVQ1UKU5j2nr7VR5

Його також можна закодувати як QR-код для спрощення комунікації:

![image](assets/4.webp)

Що стосується PayNym Bots, цих роботів, яких ви бачите на Twitter, вони є просто візуальними представленнями вашого коду оплати, створеними Samourai Wallet. Вони генеруються за допомогою хеш-функції, що робить їх майже унікальними. Ось мій з його ідентифікатором:

> +throbbingpond8B1

![image](assets/5.webp)

Ці Bots не мають жодної реальної технічної користі. Замість цього, вони сприяють взаємодії між користувачами, створюючи віртуальну візуальну ідентичність.

Для користувача процес здійснення платежу BIP47 за допомогою реалізації PayNym є надзвичайно простим. Уявімо, що Аліса хоче надіслати платежі Бобу:

1. Боб ділиться своїм QR-кодом або безпосередньо своїм повторно використовуваним кодом оплати. Він може розмістити його на своєму вебсайті, на своїх різних публічних соціальних мережах або надіслати його Алісі через інший засіб комунікації.
2. Аліса відкриває своє програмне забезпечення Samourai або Sparrow і сканує або вставляє код оплати Боба.
3. Аліса зв'язує свій PayNym з PayNym Боба ("Follow" англійською). Ця операція виконується поза ланцюгом і залишається повністю безкоштовною.

4. Аліса з'єднує свій PayNym з PayNym Боба ("Connect" англійською). Ця операція виконується "в ланцюгу". Алісі необхідно сплатити комісію за майнінг транзакції, а також фіксовану плату в 15,000 sats за послугу на Samourai. Плата за послугу не стягується на Sparrow. Цей крок називається транзакцією повідомлення.

5. Після підтвердження транзакції повідомлення, Аліса може створити транзакцію платежу BIP47 Бобу. Її гаманець автоматично генерує нову порожню адресу отримання, для якої тільки Боб має приватний ключ.

Виконання транзакції повідомлення, тобто з'єднання її PayNym, є обов'язковою передумовою для здійснення платежів BIP47. Однак, після цього, відправник може здійснювати кілька платежів одержувачу (точно 2^32) без необхідності виконання нової транзакції повідомлення.

Ви могли помітити, що існують дві різні операції для з'єднання PayNyms разом: "follow" та "connect". Операція з'єднання ("connect") відповідає транзакції повідомлення BIP47, яка є просто біткойн-транзакцією з певною інформацією, переданою через вихід OP_RETURN. Таким чином, вона допомагає встановити зашифроване спілкування між двома користувачами для виробництва спільних секретів, необхідних для генерації нових порожніх адрес отримання.

З іншого боку, операція зв'язування ("follow" або "relier") дозволяє створити зв'язок на Soroban, протоколі зашифрованого спілкування на основі Tor, спеціально розробленому командами Samourai.

Підсумовуючи:
- З'єднання двох PayNym ("підписатися") є абсолютно безкоштовним. Це допомагає налагодити зашифроване спілкування поза мережею, зокрема для використання інструментів спільних транзакцій Samourai (Stowaway або StonewallX2). Ця операція специфічна для PayNym і не описана в BIP47.
- Підключення двох PayNym передбачає витрати. Це включає виконання транзакції повідомлення для ініціації з'єднання. Вартість складається з будь-яких сервісних зборів, зборів за майнінг транзакцій та 546 сатоші, які відправляються на адресу повідомлення одержувача, щоб повідомити їх про відкриття тунелю. Ця операція пов'язана з BIP47. Після завершення відправник може здійснити кілька платежів BIP47 одержувачу.

Для з'єднання двох PayNym вони вже мають бути зв'язані.

## Посібники: Використання PayNym.

Тепер, коли ми розглянули теорію, давайте разом вивчимо практику. Ідея наведених нижче посібників полягає в тому, щоб зв'язати мій PayNym у моєму гаманці Sparrow з моїм PayNym у моєму гаманці Samourai. Перший посібник показує, як здійснити транзакцію, використовуючи повторно використовуваний платіжний код з Samourai до Sparrow, а другий посібник описує той самий механізм з Sparrow до Samourai.

> Я виконав ці посібники на Testnet. Це не справжні біткоїни.

### Створення транзакції BIP47 за допомогою гаманця Samourai.

Для початку, звичайно, вам потрібен додаток Samourai Wallet. Його можна безпосередньо завантажити з Google Play Store або за допомогою APK-файлу, доступного на офіційному сайті Samourai.

Після ініціалізації гаманця, якщо ви ще цього не зробили, запросіть свій PayNym, натиснувши на плюс (+) внизу праворуч, а потім на "PayNym".

Перший крок для здійснення платежу BIP47 полягає в отриманні повторно використовуваного платіжного коду нашого одержувача. Потім ми зможемо з'єднатися з ними та відповідно зв'язати:

![відео](assets/6.mp4)

Після підтвердження транзакції повідомлення я можу відправити кілька платежів моєму одержувачу. Кожна транзакція автоматично буде здійснена з новою порожньою адресою, ключі від якої має одержувач. Одержувачу не потрібно вживати жодних дій, все розраховується з мого боку.

Ось як здійснити транзакцію BIP47 за допомогою гаманця Samourai:

![відео](assets/7.mp4)

### Створення транзакції BIP47 за допомогою гаманця Sparrow.

Так само, як і з Samourai, вам, звичайно, потрібно мати програмне забезпечення Sparrow. Воно доступне на вашому комп'ютері. Його можна завантажити з їх [офіційного сайту](https://sparrowwallet.com/).

Переконайтеся, що перевірили підпис розробника та цілісність завантаженого програмного забезпечення перед його встановленням на вашу машину.

Створіть гаманець і запросіть свій PayNym, натиснувши на "Показати PayNym" у меню "Інструменти" у верхній панелі:

![зображення](assets/8.webp)

Потім вам потрібно буде зв'язати та підключити ваш PayNym з PayNym вашого одержувача. Для цього введіть їх повторно використовуваний платіжний код у вікні "Знайти контакт", підпишіться на них, а потім виконайте транзакцію повідомлення, натиснувши на "Зв'язати контакт":

![зображення](assets/9.webp)

Після підтвердження транзакції повідомлення ви можете відправляти платежі на повторно використовуваний платіжний код. Ось як це зробити:

![відео](assets/10.mp4)

Тепер, коли ми змогли вивчити практичний аспект реалізації PayNym BIP47, давайте подивимося, як працюють всі ці механізми та які криптографічні методи використовуються.
Для вивчення механізмів BIP47 необхідно зрозуміти структуру ієрархічного детермінованого (HD) гаманця, механізми похідних пар ключів, а також принципи криптографії на еліптичних кривих. На щастя, всю необхідну інформацію для розуміння цієї частини можна знайти на моєму блозі:
- [Розуміння шляхів похідності Bitcoin гаманця](https://www.pandul.fr/post/comprendre-les-chemins-de-d%C3%A9rivation-d-un-portefeuille-bitcoin)

- [Bitcoin гаманець - уривок з електронної книги Bitcoin Democratized 2](https://www.pandul.fr/post/le-portefeuille-bitcoin-extrait-ebook-bitcoin-d%C3%A9mocratis%C3%A9-2)

### Повторно використовуваний код платежу.

Як пояснено у другій частині цієї статті, повторно використовуваний код платежу розташований на третьому рівні HD гаманця. Він дещо порівнянний з xpub, як за своїм розташуванням, так і за структурою, а також за своєю роллю.

Ось різні частини, які складають 80-байтовий код платежу:

- Байт 0: Версія. Якщо використовується перша версія BIP47, цей байт буде дорівнювати 0x01.

- Байт 1: Бітове поле. Цей простір зарезервований для надання додаткових вказівок у випадку специфічного використання. Якщо просто використовувати PayNym, цей байт буде дорівнювати 0x00.

- Байт 2: Парність y. Цей байт вказує 0x02 або 0x03 залежно від парності (парне або непарне число) значення y-координати нашого публічного ключа. Для отримання додаткової інформації про цю практику, будь ласка, прочитайте крок 1 розділу "похідні адреси" цієї статті.

- Від байта 3 до байта 34: Значення x. Ці байти вказують x-координату нашого публічного ключа. Конкатенація x та парності y дає нам наш стиснутий публічний ключ.

- Від байта 35 до байта 66: Код ланцюга. Цей простір зарезервований для коду ланцюга, асоційованого з вищезгаданим публічним ключем.

- Від байта 67 до байта 79: Заповнення. Цей простір зарезервований для можливих майбутніх розробок. Для версії 1 ми просто заповнюємо його нулями, щоб досягти 80 байтів, які є розміром даних для виходу OP_RETURN.

Ось шістнадцяткове представлення мого повторно використовуваного коду платежу, представленого в попередньому розділі, з кольорами, що відповідають вищезазначеним байтам:
Далі, вам також потрібно додати префіксний байт "P", щоб швидко ідентифікувати, що ми маємо справу з кодом платежу. Цей байт є 0x47.

> 0x47010002a0716529bae6b36c5c9aa518a52f9c828b46ad8d907747f0d09dcd4d9a39e97c3c5f37c470c390d842f364086362f6122f412e2b0c7e7fc6e32287e364a7a36a00000000000000000000000000

Нарешті, ми розраховуємо контрольну суму цього коду платежу, використовуючи HASH256, що означає подвійне хешування за допомогою функції SHA256. Ми отримуємо перші чотири байти цього дайджесту та конкатенуємо їх в кінці (на рожевому).
Платіжний код готовий, тепер нам просто потрібно конвертувати його в Base 58:

> PM8TJSBiQmNQDwTogMAbyqJe2PE2kQXjtgh88MRTxsrnHC8zpEtJ8j7Aj628oUFk8X6P5rJ7P5qDudE4Hwq9JXSRzGcZJbdJAjM9oVQ1UKU5j2nr7VR5

Як ви можете бачити, ця конструкція тісно нагадує структуру розширеного публічного ключа типу "xpub".

Під час цього процесу для отримання нашого платіжного коду, ми використовували стиснутий публічний ключ та код ланцюга. Ці два елементи є результатом детермінованої та ієрархічної похідної від насіння гаманця, слідуючи за таким шляхом похідної: m/47'/0'/0'/
Конкретно, для отримання публічного ключа та коду ланцюга повторно використовуваного платіжного коду, ми розрахуємо майстер-приватний ключ з насіння, потім отримаємо дочірню пару з індексом 47 + 2^31 (посилена похідна). Потім ми отримуємо ще дві дочірні пари з індексом 2^31 (посилена похідна).

> Якщо ви хочете дізнатися більше про отримання дочірніх пар ключів у ієрархічному детермінованому Bitcoin гаманці, я рекомендую пройти CRYPTO301.

### Криптографічний метод: Обмін ключами Еліптичної кривої Діффі-Хеллмана (ECDH).

Криптографічний метод, що використовується в основі BIP47, це ECDH (Обмін ключами Еліптичної кривої Діффі-Хеллмана). Цей протокол є варіантом класичного обміну ключами Діффі-Хеллмана.

Діффі-Хеллман, у своїй першій версії, є протоколом узгодження ключів, представленим у 1976 році, який дозволяє двом сторонам, кожна з яких має пару публічних та приватних ключів, визначити спільний секрет, обмінюючись інформацією через незахищений канал зв'язку.

![зображення](assets/11.webp)

Цей спільний секрет (червоний ключ) потім може бути використаний для інших завдань. Зазвичай, цей спільний секрет може бути використаний для шифрування та дешифрування комунікації через незахищену мережу:

![зображення](assets/12.webp)

Для досягнення цього обміну, Діффі-Хеллман використовує модульну арифметику для розрахунку спільного секрету. Ось спрощене пояснення того, як це працює:

- Аліса та Боб домовляються про спільний колір, у цьому випадку, жовтий. Цей колір відомий всім. Це публічна інформація.

- Аліса обирає секретний колір, у цьому випадку, червоний. Вона змішує два кольори, в результаті отримуючи помаранчевий.

- Боб обирає секретний колір, у цьому випадку, бірюзово-синій. Він змішує два кольори, в результаті отримуючи небесно-блакитний.

- Аліса та Боб можуть обмінятися кольорами, які вони отримали: помаранчевий та небесно-блакитний. Цей обмін може відбутися через незахищену мережу і може бути спостережений нападниками.

- Аліса змішує небесно-блакитний колір, отриманий від Боба, зі своїм секретним кольором (червоним). Вона отримує коричневий.

- Боб змішує помаранчевий колір, отриманий від Аліси, зі своїм секретним кольором (бірюзово-синім). Він також отримує коричневий.

![зображення](assets/13.webp)
> Авторство: Оригінальна ідея: A.J. Han Vinck
Векторна версія: Flugaal
Переклад: Dereckson, Домен публічного користування, через Wikimedia Commons. https://commons.wikimedia.org/wiki/File:Diffie-Hellman_Key_Exchange_(fr).svg
У цьому спрощенні коричневий колір представляє секрет, який ділять між собою Аліса та Боб. Слід уявити, що насправді неможливо для атакуючого відокремити помаранчевий та небесно-блакитний кольори, щоб отримати секретні кольори Аліси або Боба.

Тепер давайте розглянемо його фактичну роботу. На перший погляд, Diffie-Hellman може здатися складним для розуміння. Насправді, принцип роботи майже дитячий. Перед тим як детально описати його механізми, я швидко нагадаю вам два математичні концепти, які нам будуть потрібні (і які, до речі, також використовуються в багатьох інших криптографічних методах).

1. Просте число - це натуральне число, яке має лише два дільники: 1 і саме себе. Наприклад, число 7 є простим, тому що його можна поділити лише на 1 і 7 (саме на себе). З іншого боку, число 8 не є простим, тому що його можна поділити на 1, 2, 4 і 8. Тому воно має не лише два дільники, а чотири цілі та додатні дільники.

2. "Модуль" (позначається "mod" або "%") - це математична операція, яка дозволяє двом цілим числам повернути залишок від Евклідового ділення першого числа на друге. Наприклад, 16 mod 5 дорівнює 1.

Обмін ключами Diffie-Hellman між Алісою та Бобом працює наступним чином:

- Аліса та Боб визначають два спільні числа: p і g. p є простим числом. Чим більше це число p, тим безпечніший буде Diffie-Hellman. g є примітивним коренем p. Ці два числа можуть бути передані у відкритому тексті через незахищену мережу, вони є еквівалентами жовтого кольору в спрощенні вище. Алісі та Бобу просто потрібно мати точно такі ж значення для p і g.

- Після вибору параметрів, Аліса та Боб кожен визначають власне секретне випадкове число. Випадкове число, отримане Алісою, називається a (еквівалент червоного кольору) і випадкове число, отримане Бобом, називається b (еквівалент бірюзового кольору). Ці два числа повинні залишатися в секреті.

- Замість обміну цими числами a і b, кожна сторона розраховуватиме A (з великої літери) і B (з великої літери) так, що:

> A дорівнює g, піднесеному до степеня a по модулю p:
> A = g^a % p

> B дорівнює g, піднесеному до степеня b по модулю p:
> B = g^b % p

- Ці числа A (еквівалент помаранчевого кольору) і B (еквівалент небесно-блакитного кольору) будуть обміняні між двома сторонами. Обмін може відбуватися у відкритому тексті через незахищену мережу.

- Аліса, яка тепер знає B, розрахує значення z так, що:

> z дорівнює B, піднесеному до степеня a по модулю p:
> z = B^a % p

- Нагадуємо, B = g^b % p. Отже:

  > z = B^a % p
  > z = (g^b)^a % p
  >
  > Згідно з правилами піднесення до степеня:
  >
  > (x^n)^m = x^nm
  >
  > Отже:
  >
  > z = g^ba % p

- Боб, який тепер знає A, також розрахує значення z наступним чином:
z дорівнює A у степені b за модулем p:
> z = A^b % p

Отже:
> z = (g^a)^b % p
> z = g^ab % p
> z = g^ba % p

Завдяки дистрибутивності операції за модулем, Аліса та Боб знаходять абсолютно однакове значення для z. Це число представляє їх спільний секрет, який еквівалентний кольору коричневому в попередньому поясненні. Вони можуть використовувати цей спільний секрет для шифрування комунікації між собою по незахищеній мережі.

![Діаграма технічної операції Diffie-Hellman](assets/14.webp)

Атакуючий, який володіє p, g, A та B, не зможе обчислити a, b або z. Виконання цієї операції вимагало б зворотного піднесення до степеня, що неможливо зробити інакше, ніж спробувати всі можливості одну за одною, оскільки ми працюємо з кінцевим полем. Це було б еквівалентно обчисленню дискретного логарифму, який є оберненим до піднесення до степеня в циклічній кінцевій групі.

Отже, доки ми вибираємо достатньо великі значення для a, b та p, Diffie-Hellman є безпечним. Зазвичай, з параметрами 2048 біт (число з 600 цифрами в десятковому форматі), перевірка всіх можливостей для a та b була б непрактичною. На сьогодні, з числами такого розміру, алгоритм вважається безпечним.

Саме тут лежить основний недолік протоколу Diffie-Hellman. Для забезпечення безпеки алгоритм має використовувати великі числа. В результаті, зараз віддається перевага алгоритму ECDH, який є варіантом Diffie-Hellman, що використовує алгебраїчну криву, зокрема еліптичну криву. Це дозволяє нам працювати з набагато меншими числами, зберігаючи еквівалентну безпеку, тим самим зменшуючи вимоги до обчислювальних та зберігаючих ресурсів.

Загальний принцип алгоритму залишається тим самим. Однак, замість використання випадкового числа a та числа A, обчисленого з a за допомогою модульного піднесення до степеня, ми будемо використовувати пару ключів, встановлених на еліптичній кривій. Замість покладання на дистрибутивність операції за модулем, ми будемо використовувати груповий закон на еліптичних кривих, зокрема асоціативність цього закону.
Якщо ви не знаєте, як працюють приватні та публічні ключі на еліптичній кривій, я поясню основи цього методу в перших шести частинах цієї статті.

Грубо кажучи, приватний ключ - це випадкове число між 1 та n-1 (де n - порядок кривої), а публічний ключ - це унікальна точка на кривій, визначена приватним ключем через додавання точок та подвоєння від генераторної точки, як наступне:

> K = k·G

Де K - публічний ключ, k - приватний ключ, а G - генераторна точка.

Однією з властивостей цієї пари ключів є те, що дуже легко визначити K, якщо ви знаєте k та G, але наразі неможливо визначити k, якщо ви знаєте K та G. Це одностороння функція.

Іншими словами, ви легко можете обчислити публічний ключ, якщо знаєте приватний ключ, але неможливо обчислити приватний ключ, якщо знаєте публічний ключ. Ця безпека знову ж таки базується на неможливості обчислення дискретного логарифму.

Ми використовуватимемо цю властивість для адаптації нашого алгоритму Diffie-Hellman. Таким чином, принцип роботи ECDH є наступним:

- Аліса та Боб домовляються про криптографічно безпечну еліптичну криву та її параметри. Ця інформація є публічною.
- Аліса генерує випадкове число ka, яке буде її приватним ключем. Цей приватний ключ має залишатися в таємниці. Вона визначає свій публічний ключ Ka, додаючи та подвоюючи точки на обраній еліптичній кривій.
> Ka = ka·G

- Боб також генерує випадкове число kb, яке буде його приватним ключем. Він розраховує асоційований публічний ключ Kb.

> Kb = kb·G

- Аліса та Боб обмінюються своїми публічними ключами Ka та Kb через незахищену публічну мережу.

- Аліса розраховує точку (x, y) на кривій, застосовуючи свій приватний ключ ka до публічного ключа Боба Kb.

> (x, y) = ka·Kb

- Боб розраховує точку (x, y) на кривій, застосовуючи свій приватний ключ kb до публічного ключа Аліси Ka.

> (x, y) = kb·Ka

- Аліса та Боб отримують однакову точку на еліптичній кривій. Спільною таємницею буде x-координата цієї точки.

Вони дійсно отримують однакову спільну таємницю, тому що:

> (x, y) = ka·Kb = ka·kb·G = kb·ka·G = kb·Ka

Потенційний нападник, який спостерігає за незахищеною публічною мережею, може отримати лише публічні ключі кожної сторони та параметри обраної кривої. Як було пояснено раніше, ці дві частини інформації самі по собі не дозволяють визначити приватні ключі, тому нападник не може отримати доступ до таємниці.
ECDH - це алгоритм, який дозволяє обмін ключами. Він часто використовується разом з іншими криптографічними методами для визначення протоколу. Наприклад, ECDH використовується в ядрі TLS (Transport Layer Security), протоколу шифрування та аутентифікації, який використовується для транспортного шару інтернету. TLS використовує ECDHE для обміну ключами, варіант ECDH, де ключі є ефемерними, щоб забезпечити постійну конфіденційність. Крім ECDHE, TLS також використовує алгоритм аутентифікації, як-от ECDSA, алгоритм шифрування, як-от AES, та хеш-функцію, як-от SHA256.

TLS визначає "s" у "https" та маленький замковий значок, який ви бачите у верхньому лівому кутку вашого інтернет-браузера, що гарантує зашифроване спілкування. Таким чином, ви зараз використовуєте ECDH, читаючи цю статтю, і, ймовірно, використовуєте його щодня, не усвідомлюючи цього.

### Транзакція повідомлення.

Як ми виявили в попередньому розділі, ECDH є варіантом обміну Діффі-Хеллмана, який включає пари ключів, встановлені на еліптичній кривій. На щастя, у наших Bitcoin гаманцях є багато пар ключів, які відповідають цьому стандарту!

Ідея полягає в тому, щоб використовувати пари ключів з ієрархічних детермінованих Bitcoin гаманців обох сторін для створення спільних та ефемерних таємниць між ними. У BIP47 замість цього використовується ECDHE (Еліптична Крива Діффі-Хеллман Ефемерний).

Спочатку в BIP47 ECDHE використовується для передачі платіжного коду відправника одержувачу. Це відома транзакція повідомлення. Для використання BIP47 обидві сторони (відправник, який надсилає платежі, та одержувач, який отримує платежі) повинні знати платіжний код один одного. Це необхідно для виведення ефемерних публічних ключів і, отже, призначених адрес отримання.
Перед цим обміном відправник логічно вже знає платіжний код одержувача, оскільки міг отримати його поза мережею, наприклад, з їхнього вебсайту або соціальних мереж. Однак одержувач не обов'язково може знати платіжний код відправника. Його потрібно передати їм, інакше вони не зможуть вивести свої ефемерні ключі і тому не зможуть знати, де їхні біткоїни, і розблокувати свої кошти. Це може бути передано їм поза мережею, використовуючи іншу систему комунікації, але це становитиме проблему, якщо гаманець відновлюється з seed. Дійсно, як я вже згадував, адреси BIP47 не походять від seed одержувача (інакше було б краще використовувати один з їхніх xpubs безпосередньо), а є результатом розрахунку, що включає платіжний код як одержувача, так і відправника. Тому, якщо одержувач втрачає свій гаманець і намагається відновити його зі свого seed, їм обов'язково потрібно мати всі платіжні коди людей, які надсилали їм біткоїни через BIP47.

Було б можливо використовувати BIP47 без цієї транзакції повідомлення, але кожному користувачеві потрібно було б зберегти платіжні коди своїх колег. Ця ситуація залишатиметься некерованою, доки не буде знайдено простий і надійний спосіб створення, зберігання та оновлення цих резервних копій. Тому транзакція повідомлення майже обов'язкова в поточному стані речей.

Крім своєї ролі резервного копіювання платіжних кодів, як це випливає з назви, ця транзакція також служить повідомленням для одержувача. Вона інформує їхній клієнт, що тунель щойно був відкритий.

Перед тим, як детальніше пояснити технічне функціонування транзакції повідомлення, я хотів би трохи поговорити про модель приватності. Дійсно, модель приватності BIP47 виправдовує певні заходи обережності, вжиті під час створення цієї початкової транзакції.

Сам по собі платіжний код не становить прямої загрози для приватності. На відміну від класичної моделі Bitcoin, яка дозволяє переривати потік інформації між ідентичністю користувача та транзакціями, особливо шляхом збереження анонімності публічних ключів, платіжний код може бути безпосередньо пов'язаний з ідентичністю. Це не обов'язково, але це зв'язок не є небезпечним.

Дійсно, платіжний код не походить безпосередньо адреси, що використовуються для отримання платежів BIP47. Натомість адреси отримуються шляхом застосування ECDHE між дочірніми ключами платіжних кодів обох сторін.

Тому сам по собі платіжний код не становить прямої загрози для приватності, оскільки лише адреса повідомлення походить від нього. З цього можна зробити деякі висновки, але зазвичай не можна знати, з ким ви здійснюєте транзакції.

Тому важливо підтримувати строге розділення між платіжними кодами користувачів. У цьому контексті початковий етап комунікації коду є критичним моментом для приватності платежів, і все ж він обов'язковий для належного функціонування протоколу. Якщо один з платіжних кодів може бути публічно отриманий (наприклад, з вебсайту), другий код, тобто код відправника, не повинен асоціюватися з першим.

Наприклад, уявімо, що я хочу зробити пожертву з BIP47 мирному протестному руху в Канаді:

- Ця організація опублікувала свій платіжний код безпосередньо на своєму вебсайті або платформах соціальних мереж.
- Таким чином, цей код асоціюється з рухом.

- Я отримую цей платіжний код.

- Перед тим, як я можу надіслати їм транзакцію, я повинен переконатися, що вони знають про мій особистий платіжний код, який також асоціюється з моєю ідентичністю, оскільки я використовую його для отримання транзакцій з моїх соціальних мереж.

Як я можу передати його їм? Якщо я надішлю його їм за допомогою звичайного засобу комунікації, інформація може витекти, і мене можуть ідентифікувати як особу, що підтримує мирні рухи.
Транзакція сповіщення, безумовно, не є єдиним рішенням для таємної передачі коду оплати відправника, але наразі вона ідеально виконує цю роль, застосовуючи кілька рівнів безпеки.
На діаграмі нижче червоні лінії представляють момент, коли потік інформації має бути перерваний, а чорні стрілки представляють незаперечні зв'язки, які може встановити зовнішній спостерігач:

![Діаграма моделі конфіденційності для повторно використовуваного коду оплати](assets/15.webp)

На практиці, для класичної моделі конфіденційності Bitcoin, часто важко повністю перервати потік інформації між парою ключів та користувачем, особливо під час проведення віддалених транзакцій. Наприклад, у випадку кампанії збору пожертв, одержувач буде змушений розкрити адресу або публічний ключ на своєму вебсайті або на платформах соціальних медіа. Належне використання BIP47, тобто з транзакцією сповіщення, вирішує цю проблему через ECDHE та шар шифрування, який ми вивчимо.

Очевидно, класична модель конфіденційності Bitcoin все ще спостерігається на рівні ефемерних публічних ключів, похідних від асоціації двох платіжних кодів. Дві моделі є взаємозалежними. Я просто хочу тут підкреслити, що, на відміну від класичного використання публічного ключа для отримання біткойнів, платіжний код може бути асоційований з ідентичністю, оскільки інформація "Боб робить транзакцію з Алісою" переривається в інший момент. Платіжний код використовується для генерації адрес оплати, але, спостерігаючи лише за блокчейном, неможливо асоціювати транзакцію оплати BIP47 з використаними для її здійснення платіжними кодами.

### Конструкція транзакції сповіщення.

Тепер давайте подивимося, як працює ця транзакція сповіщення. Уявімо, що Аліса хоче надіслати кошти Бобу, використовуючи BIP47. У моєму прикладі, Аліса виступає як відправник, а Боб як одержувач. Боб вже опублікував свій платіжний код на своєму вебсайті, тому Аліса вже знає платіжний код Боба.

1. Аліса обчислює спільний секрет за допомогою ECDH:

- Вона вибирає пару ключів зі свого HD гаманця, розташовану на іншій гілці, ніж її платіжний код. Зауважте, що ця пара не повинна бути легко асоційована з адресою сповіщення Аліси або ідентичністю Аліси (див. попередній розділ).
- Аліса вибирає приватний ключ з цієї пари. Ми назвемо його "a" (маленька літера).

> a

- Аліса отримує публічний ключ, асоційований з адресою сповіщення Боба. Цей ключ є першою дитиною, похідною від платіжного коду Боба (індекс 0). Ми назвемо цей публічний ключ "B" (велика літера). Приватний ключ, асоційований з цим публічним ключем, називається "b" (маленька літера). "B" визначається шляхом додавання точок і подвоєння на еліптичній кривій від "G" (точка генератора) з "b" (приватний ключ).

> B = b·G

- Аліса обчислює секретну точку "S" (велика літера) на еліптичній кривій шляхом додавання точок і подвоєння, застосовуючи свій приватний ключ "a" до публічного ключа Боба "B".

> S = a·B

- Аліса обчислює коефіцієнт засліплення "f", який буде використовуватися для шифрування її платіжного коду. Для цього вона генерує псевдовипадкове число за допомогою функції HMAC-SHA512. Як другий вхід до цієї функції, вона використовує значення, яке тільки Боб зможе отримати: (x), яке є x-координатою раніше обчисленої секретної точки. Перший вхід - це (o), яке є UTXO, споживаним як вхід до цієї транзакції (вихідний пункт).

> f = HMAC-SHA512(o, x)

2. Аліса перетворює свій особистий платіжний код на базу 2 (двійковий формат).
3. Вона використовує цей засліплюючий фактор як ключ для виконання симетричного шифрування вантажу свого платіжного коду. Алгоритм шифрування, що використовується, - це просто XOR. Виконувана операція схожа на шифр Вернама, також відомий як "одноразовий блокнот":
- Спочатку Аліса розділяє свій засліплюючий фактор на дві частини: перші 32 байти називаються "f1", а останні 32 байти - "f2". Отже, маємо:

> f = f1 || f2

- Аліса обчислює шифртекст (x') координати x публічного ключа (x) свого платіжного коду, і окремо обчислює шифртекст (c') свого ланцюгового коду (c). "f1" та "f2" діють як ключі шифрування, і використовується операція XOR.

> x' = x XOR f1
>
> c' = c XOR f2

- Аліса замінює фактичні значення абсциси публічного ключа (x) та ланцюгового коду (c) у своєму платіжному коді на зашифровані значення (x') та (c').

Перед тим, як продовжити технічний опис цієї транзакції повідомлення, давайте на мить зупинимося, щоб обговорити операцію XOR. XOR - це побітовий логічний оператор, заснований на булевій алгебрі. Для двох бітових операндів він повертає 1, якщо відповідні біти різні, і повертає 0, якщо відповідні біти однакові. Ось таблиця істинності для XOR на основі значень операндів D та E:

| D   | E   | D XOR E |
| --- | --- | ------- |
| 0   | 0   | 0       |
| 0   | 1   | 1       |
| 1   | 0   | 1       |
| 1   | 1   | 0       |

Наприклад:

> 0110 XOR 1110 = 1000

Або:

> 010011 XOR 110110 = 100101

З використанням ECDH, застосування XOR як шару шифрування є особливо послідовним. По-перше, завдяки цьому оператору, шифрування є симетричним. Це дозволяє одержувачу розшифрувати платіжний код за допомогою того ж ключа, що використовувався для шифрування. Ключ шифрування та розшифрування обчислюється з спільного секрету за допомогою ECDH.

Ця симетрія забезпечується завдяки властивостям комутативності та асоціативності оператора XOR:

- Інші властивості:
  -> D ⊕ D = 0
  -> D ⊕ 0 = D

- Комутативність:
  D ⊕ E = E ⊕ D

- Асоціативність:
  D ⊕ (E ⊕ Z) = (D ⊕ E) ⊕ Z = D ⊕ E ⊕ Z

- Симетрія:
  Якщо: D ⊕ E = L
  Тоді: D ⊕ L = D ⊕ (D ⊕ E) = D ⊕ D ⊕ E = 0 ⊕ E = E
  -> D ⊕ L = E
Далі, цей метод шифрування дуже схожий на шифр Вернама (Одноразовий Блокнот), єдиний алгоритм шифрування, відомий на сьогодні, який має безумовну (або абсолютну) безпеку. Для того, щоб шифр Вернама мав цю характеристику, ключ шифрування має бути абсолютно випадковим, мати такий самий розмір, як і повідомлення, та використовуватися лише один раз. У методі шифрування, що використовується тут для BIP47, ключ дійсно має такий самий розмір, як і повідомлення, а фактор засліплення точно такий самий розмір, як і конкатенація x-координати публічного ключа з кодом ланцюжка платежу. Цей ключ шифрування дійсно використовується лише один раз. Однак, цей ключ не походить з досконало випадкового джерела, оскільки він є HMAC. Він скоріше псевдовипадковий. Тому це не шифр Вернама, але метод схожий.
Повернімося до нашої конструкції повідомлення транзакції:

4. Наразі Аліса має свій платіжний код з зашифрованим вантажем. Вона створить і транслюватиме транзакцію, що включає її публічний ключ "A" як вхід, вихід на повідомлювальну адресу Боба, та вихід OP_RETURN, що складається з її платіжного коду з зашифрованим вантажем. Ця транзакція є повідомлювальною транзакцією.

OP_RETURN - це Opcode, який є скриптом, що позначає вихід транзакції Bitcoin як недійсний. Сьогодні він використовується для трансляції або закріплення інформації на блокчейні Bitcoin. Він може зберігати до 80 байтів даних, які записуються на ланцюжок і тому видимі для всіх інших користувачів.

Як ми бачили в попередньому розділі, Діффі-Хеллман використовується для генерації спільного секрету між двома користувачами, які спілкуються через небезпечну мережу, потенційно спостережувану нападниками. У BIP47, ECDH використовується для спілкування в мережі Bitcoin, яка за своєю природою є прозорою комунікаційною мережею, спостережуваною багатьма нападниками. Спільний секрет, розрахований через обмін ключами Діффі-Хеллмана на еліптичній кривій, потім використовується для шифрування секретної інформації, яка має бути передана: платіжний код відправника (Аліси).

Ось діаграма, взята з BIP47, яка ілюструє те, що ми щойно описали:

![Діаграма Аліса відправляє свій маскований платіжний код на повідомлювальну адресу Боба](assets/16.webp)

Кредит: Повторно використовувані платіжні коди для ієрархічних детермінованих гаманців, Юстус Ранв'є. https://github.com/bitcoin/bips/blob/master/bip-0047.mediawiki

Якщо ми порівняємо цю діаграму з тим, що я описав раніше:

- "Wallet Priv-Key" зі сторони Аліси відповідає: a.

- "Child Pub-Key 0" зі сторони Боба відповідає: B.
- "Notification Shared Secret" відповідає: f.
- "Masked Payment Code" відповідає зашифрованому платіжному коду, тобто з зашифрованим вантажем: x' та c'.

- "Notification Transaction" - це транзакція, яка містить OP_RETURN.

Давайте підсумуємо кроки, через які ми щойно пройшли, щоб виконати повідомлювальну транзакцію:

- Аліса отримує платіжний код та повідомлювальну адресу Боба.

- Аліса вибирає UTXO, який належить їй у її HD гаманці з відповідною парою ключів.

- Вона розраховує секретну точку на еліптичній кривій, використовуючи ECDH.

- Вона використовує цю секретну точку для розрахунку HMAC, який є фактором засліплення.

- Вона використовує цей фактор засліплення для шифрування вантажу свого особистого платіжного коду.

- Вона використовує вихід транзакції OP_RETURN для передачі маскованого платіжного коду Бобу.

Щоб краще зрозуміти його роботу, особливо використання OP_RETURN, давайте разом вивчимо реальну повідомлювальну транзакцію. Я виконав таку транзакцію на Testnet, яку ви можете знайти, натиснувши тут:
Спостерігаючи за цією транзакцією, ми вже можемо побачити, що вона має один вхід і 4 виходи:

- Перший вихід - це OP_RETURN, який містить мій маскований платіжний код.

- Другий вихід у 546 сатоші вказує на адресу сповіщення одержувача.

- Третій вихід у 15,000 сатоші представляє собою плату за сервіс, оскільки я використовував гаманець Samourai для створення цієї транзакції.

- Четвертий вихід у два мільйони сатоші представляє собою решту, тобто різницю, що залишилася з мого входу, яка повертається на іншу адресу, що належить мені.

Найцікавіше для вивчення, безумовно, вихід 0, що використовує OP_RETURN. Давайте розглянемо детальніше, що він містить:

Ми виявляємо шістнадцятковий скрипт виходу:

> 6a4c50010002b13b2911719409d704ecc69f74fa315a6cb20fdd6ee39bc9874667703d67b164927b0e88f89f3f8b963549eab2533b5d7ed481a3bea7e953b546b4e91b6f50d800000000000000000000000000

У цьому скрипті ми можемо розбити кілька частин:
Серед опкодів ми можемо впізнати 0x6a, який відноситься до OP_RETURN, і 0x4c, який відноситься до OP_PUSHDATA1. Байт, що слідує за цим опкодом, вказує розмір наступного вантажу. Він вказує 0x50, що становить 80 байтів.

Далі йде платіжний код з зашифрованим вантажем.

Ось мій платіжний код, використаний у цій транзакції:

> У форматі base 58:
>
> PM8TJQCyt6ovbozreUCBrfKqmSVmTzJ5vjqse58LnBzKFFZTwny3KfCDdwTqAEYVasn11tTMPc2FJsFygFd3YzsHvwNXLEQNADgxeGnMK8Ugmin62TZU
>
> У форматі base 16 (HEX):
> 4701000277507c9c17a89cfca2d3af554745d6c2db0e7f6b2721a3941a504933103cc42add94881210d6e752a9abc8a9fa0070e85184993c4f643f1121dd807dd556d1dc000000000000000000000000008604e4db

Якщо ми порівняємо мій платіжний код з OP_RETURN, ми можемо побачити, що HRP (у коричневому кольорі) та контрольна сума (у рожевому кольорі) не передаються. Це нормально, оскільки ця інформація призначена для людей.
Далі ми можемо розпізнати (зеленим кольором) версію (0x01), бітове поле (0x00) та парність публічного ключа (0x02). І, наприкінці платіжного коду, пусті байти чорним кольором (0x00), які дозволяють доповнення до загального обсягу в 80 байтів. Вся ця метадана передається у відкритому тексті (незашифрована). Нарешті, ми можемо спостерігати, що x-координата публічного ключа (синім кольором) та ланцюговий код (червоним кольором) були зашифровані. Це становить навантаження платіжного коду.

### Отримання транзакції повідомлення.

Тепер, коли Аліса відправила транзакцію повідомлення Бобу, давайте подивимося, як він її інтерпретує.

Нагадаємо, що Боб повинен мати доступ до платіжного коду Аліси. Без цієї інформації, як ми побачимо в наступному розділі, він не зможе вивести пари ключів, створені Алісою, і тому не зможе отримати доступ до своїх біткойнів, отриманих за допомогою BIP47. Наразі навантаження платіжного коду Аліси зашифроване. Давайте разом подивимося, як Боб його розшифровує.

1. Боб моніторить транзакції, які створюють виходи на його адресу повідомлень.

2. Коли транзакція має вихід на його адресу повідомлень, Боб аналізує її, щоб побачити, чи містить вона вихід OP_RETURN, який відповідає стандарту BIP47.

3. Якщо перший байт навантаження OP_RETURN становить 0x01, Боб починає пошук можливого спільного секрету з ECDH:

- Боб вибирає публічний ключ у вхідній транзакції. Тобто публічний ключ Аліси під назвою "A" з:

> A = a·G

- Боб вибирає приватний ключ "b", асоційований з його особистою адресою повідомлень:

> b

- Боб розраховує секретну точку "S" (спільний секрет ECDH) на еліптичній кривій, додаючи та подвоюючи точки, застосовуючи свій приватний ключ "b" до публічного ключа Аліси "A":

> S = b·A

- Боб визначає фактор затемнення "f", який дозволить йому розшифрувати навантаження платіжного коду Аліси. Так само, як Аліса розрахувала його раніше, Боб знайде "f", застосувавши HMAC-SHA512 до (x) значення x-координати секретної точки "S", і до (o) UTXO, використаного як вхід у цій транзакції повідомлення:

> f = HMAC-SHA512(o, x)

4. Боб інтерпретує дані в OP_RETURN транзакції повідомлення як платіжний код. Він просто розшифровує навантаження цього потенційного платіжного коду, використовуючи фактор затемнення "f".

- Боб розділяє фактор затемнення "f" на дві частини: перші 32 байти "f" будуть "f1", а останні 32 байти будуть "f2".
- Боб розшифровує зашифроване значення x-координати (x') публічного ключа платіжного коду Аліси:

> x = x' XOR f1

- Боб розшифровує зашифроване значення ланцюгового коду (c') платіжного коду Аліси:

> c = c' XOR f2

5. Боб перевіряє, чи є значення публічного ключа платіжного коду Аліси частиною групи secp256k1. Якщо так, він інтерпретує його як дійсний платіжний код. В іншому випадку він ігнорує транзакцію.

Тепер, коли Боб знає платіжний код Аліси, вона може відправити йому до 2^32 платежів, не потребуючи повторно виконувати транзакцію повідомлення, як це.

Чому це працює? Як Боб може визначити той самий фактор затемнення, що й Аліса, і розшифрувати її платіжний код? Давайте детальніше розглянемо процес ECDH на основі того, що ми щойно описали.
По-перше, ми маємо справу з симетричним шифруванням. Це означає, що ключ шифрування та ключ дешифрування є однаковими. У цьому випадку ключ у повідомленні транзакції є фактором засліплення (f = f1 || f2). Алісі та Бобу потрібно отримати однакове значення для f, не передаючи його безпосередньо, оскільки атакуючий міг би перехопити його та розшифрувати секретну інформацію.
Цей фактор засліплення отримують, застосовуючи HMAC-SHA512 до двох значень: x-координати секретної точки та використаного UTXO у вхідній транзакції. Таким чином, Бобу потрібно мати ці дві частини інформації, щоб розшифрувати платіжний код Аліси.

Для вхідного UTXO Боб може просто отримати його, спостерігаючи за повідомленням транзакції. Для секретної точки Бобу доведеться використовувати ECDH.

Як було показано у розділі про Діффі-Хеллмана, обмінюючись відповідними публічними ключами та таємно застосовуючи свої приватні ключі до публічного ключа іншого, Аліса та Боб можуть знайти конкретну та секретну точку на еліптичній кривій. Повідомлення транзакції базується на цьому механізмі:

> Ключова пара Боба:
>
> B = b·G
>
> Ключова пара Аліси:
>
> A = a·G
>
> Для секретної точки S (x,y):
>
> S = a·B = a·b·G = b·a·G = b·A

![Діаграма генерації спільного секрету з ECDHE](assets/19.webp)
Тепер, коли Боб знає платіжний код Аліси, він зможе виявляти її платежі BIP47 та виводити приватні ключі, які блокують отримані біткоїни.
![Боб інтерпретує повідомлення транзакції Аліси](assets/20.webp)

Кредит: Повторно використовувані платіжні коди для ієрархічних детермінованих гаманців, Justus Ranvier. https://github.com/bitcoin/bips/blob/master/bip-0047.mediawiki

Якщо ми порівняємо цю діаграму з тим, що я вам раніше описав:

- "Wallet Pub-Key" на стороні Аліси відповідає: A.

- "Child Priv-Key 0" на стороні Боба відповідає: b.

- "Notification Shared Secret" відповідає: f.

- "Masked Payment Code" відповідає маскованому платіжному коду Аліси, тобто з зашифрованим вантажем: x' та c'.

- "Notification Transaction" - це транзакція, яка містить OP_RETURN.

Дозвольте мені підсумувати кроки, які ми щойно разом розглянули, щоб отримати та інтерпретувати повідомлення транзакції:

- Боб моніторить вихідні транзакції на свою адресу повідомлень.

- Коли він виявляє одну, він отримує інформацію, що міститься в OP_RETURN.

- Боб вибирає вхідний публічний ключ і розраховує секретну точку, використовуючи ECDH.

- Він використовує цю секретну точку для розрахунку HMAC, який є фактором засліплення.

- Він використовує цей фактор засліплення для розшифрування платіжного коду Аліси, що міститься в OP_RETURN.

### Платіжна транзакція BIP47.

Тепер давайте розглянемо процес платежу з BIP47. Нагадую вам про поточний стан ситуації:

- Аліса знає платіжний код Боба, який вона просто отримала з його вебсайту.

- Боб знає платіжний код Аліси завдяки повідомленню транзакції.

- Аліса здійснить початковий платіж Бобу. Вона може зробити багато інших таким же чином.

Перед тим, як пояснити вам цей процес, я вважаю важливим нагадати вам, з якими індексами ми зараз працюємо:

Ми описуємо шлях похідності платіжного коду так: m/47'/0'/0'/. 

Наступна глибина розподіляє індекси наступним чином:
- Перша звичайна (не посилена) пара дочірніх ключів використовується для генерації адреси сповіщення, про яку ми говорили в попередньому розділі: m/47'/0'/0'/0/.
- Звичайні пари дочірніх ключів використовуються в ECDH для генерації адрес отримання платежів BIP47, як ми побачимо в цьому розділі: m/47'/0'/0'/ від 0 до 2,147,483,647/.

- Посилені пари дочірніх ключів є ефемерними платіжними кодами: m/47'/0'/0'/ від 0' до 2,147,483,647'/.
  Кожного разу, коли Аліса хоче відправити платіж Бобу, вона генерує нову унікальну порожню адресу, знову завдяки протоколу ECDH:
- Аліса вибирає перший приватний ключ, отриманий з її особистого повторно використовуваного платіжного коду:

> a

- Аліса вибирає перший невикористаний публічний ключ, отриманий з платіжного коду Боба. Цей публічний ключ, ми назвемо його "B". Він асоційований з приватним ключем "b", який знає тільки Боб.

> B = b·G

- Аліса розраховує секретну точку "S" на еліптичній кривій, додаючи та подвоюючи точки, застосовуючи свій приватний ключ "a" до публічного ключа Боба "B":

> S = a·B

- З цієї секретної точки Аліса розраховуватиме спільний секрет "s" (маленькі літери). Для цього вона вибирає x-координату секретної точки "S", яку називають "Sx", і передає це значення в функцію хешування SHA256.

> s = SHA256(Sx)

Не довіряйте. Перевіряйте! Якщо ви хочете зрозуміти базові принципи функції хешування, ви знайдете все необхідне в цій статті. І якщо ви не довіряєте NIST (і ви праві), і хочете зрозуміти детально, як працює SHA256, я все пояснюю в цій статті французькою мовою.

- Аліса використовує цей спільний секрет "s" для розрахунку адреси отримання платежів Bitcoin. Спочатку вона перевіряє, чи "s" знаходиться в межах порядку кривої secp256k1. Якщо ні, вона збільшує індекс публічного ключа Боба, щоб отримати інший спільний секрет.

- По-друге, вона розраховує публічний ключ "K0", додаючи точки "B" та "s·G" на еліптичній кривій. Іншими словами, Аліса додає публічний ключ, отриманий з платіжного коду Боба "B", з іншою точкою, розрахованою на еліптичній кривій шляхом додавання та подвоєння точок зі спільним секретом "s" від генераторної точки кривої secp256k1 "G". Ця нова точка представляє публічний ключ, і ми називаємо його "K0":

> K0 = B + s·G

- З цим публічним ключем "K0" Аліса може отримати порожню адресу отримання в стандартний спосіб (наприклад, SegWit V0 у форматі Bech32).

Як тільки Аліса має цю адресу отримання "K0", що належить Бобу, вона може створити стандартну транзакцію Bitcoin, вибравши UTXO, який належить їй на іншій гілці її HD гаманця, і витративши його на адресу "K0" Боба.

![Аліса відправляє біткоїни з BIP47 Бобу](assets/21.webp)

Кредит: Повторно використовувані платіжні коди для ієрархічних детермінованих гаманців, Justus Ranvier. https://github.com/bitcoin/bips/blob/master/bip-0047.mediawiki
Якщо ми порівняємо цю схему з тим, що я описав вам раніше:

- "Child Priv-Key" зі сторони Аліси відповідає: a.
- "Child Pub-Key 0" зі сторони Боба відповідає: B.
- "Payment Secret 0" відповідає: s.
- "Payment Pub-Key 0" відповідає: K0.
Дозвольте мені підсумувати кроки, які ми щойно пройшли разом, щоб здійснити платіж BIP47:

- Аліса вибирає перший похідний дочірній приватний ключ зі свого особистого платіжного коду.
- Вона розраховує секретну точку на еліптичній кривій, використовуючи ECDH з першого невикористаного похідного дочірнього публічного ключа з платіжного коду Боба.
- Вона використовує цю секретну точку для розрахунку спільного секрету за допомогою SHA256.
- Вона використовує цей спільний секрет для розрахунку нової секретної точки на еліптичній кривій.
- Вона додає цю нову секретну точку до публічного ключа Боба.
- Вона отримує новий ефемерний публічний ключ, приватний ключ до якого має лише Боб.
- Аліса може відправити звичайну транзакцію Бобу на отриманий ефемерний адрес.

Якщо вона хоче зробити другий платіж, вона повторить вищезазначені кроки, за винятком того, що вибере другий похідний публічний ключ з платіжного коду Боба. Тобто наступний невикористаний ключ. Тоді вона матиме другу адресу для отримання, що належить Бобу, "K1".

![Аліса виводить три адреси BIP47 для отримання Бобом](assets/22.webp)

Автор: Reusable Payment Codes for Hierarchical Deterministic Wallets, Justus Ranvier. https://github.com/bitcoin/bips/blob/master/bip-0047.mediawiki

Вона може продовжувати таким чином і виводити до 2^32 порожніх адрес, що належать Бобу.

З зовнішньої перспективи, спостерігаючи за блокчейном Bitcoin, теоретично неможливо відрізнити платіж BIP47 від звичайного платежу. Ось приклад транзакції платежу BIP47 на Testnet:

https://blockstream.info/testnet/tx/94b2e59510f2e1fa78411634c98a77bbb638e28fb2da00c9f359cd5fc8f87254

TXID:

> 94b2e59510f2e1fa78411634c98a77bbb638e28fb2da00c9f359cd5fc8f87254

Це виглядає як звичайна транзакція з витраченим входом, вихідним платежем у 210,000 сатоші та рештою.

![Транзакція Bitcoin з платежем BIP47](assets/23.webp)

Автор: https://blockstream.info/

### Отримання платежу BIP47 та виведення приватного ключа.

Аліса щойно здійснила свій перший платіж на порожню адресу BIP47, яка належить Бобу. Тепер давайте подивимося, як Боб отримує цей платіж. Ми також побачимо, чому Аліса не має доступу до приватного ключа адреси, яку вона щойно згенерувала, і як Боб отримує цей ключ, щоб витратити отримані біткоїни.

Як тільки Боб отримує повідомлення про транзакцію від Аліси, він виводить публічний ключ BIP47 "K0" навіть до того, як вона відправить будь-який платіж на нього. Таким чином, він спостерігає за будь-яким платежем на асоційовану адресу. Насправді, він одразу виводить кілька адрес, за якими він буде спостерігати (K0, K1, K2, K3...). Ось як він виводить цей публічний ключ "K0":

- Боб вибирає перший дочірній приватний ключ, похідний від його платіжного коду. Цей приватний ключ називається "b". Він асоційований з публічним ключем "B", який Аліса використовувала на попередньому кроці:

> b

- Боб вибирає перший похідний публічний ключ Аліси з її платіжного коду. Цей ключ називається "A". Він асоційований з приватним ключем "a", який Аліса використовувала у своїх розрахунках, і про який тільки Аліса знає. Боб може виконати цей процес, тому що він знає платіжний код Аліси, який був переданий йому з повідомленням про транзакцію.

> A = a·G
- Боб обчислює секретну точку "S", додаючи та подвоюючи точки на еліптичній кривій, застосовуючи свій приватний ключ "b" до публічного ключа Аліси "A". Тут ми використовуємо ECDH, що гарантує, що ця точка "S" буде однаковою як для Боба, так і для Аліси.
> S = b·A

- Так само, як і Аліса, Боб ізолює x-координату цієї точки "S". Ми назвали це значення "Sx". Він пропускає це значення через функцію SHA256, щоб знайти спільний секрет "s" (маленька літера).

> s = SHA256(Sx)

- Так само, як і Аліса, Боб обчислює точку "s·G" на еліптичній кривій. Потім він додає цю секретну точку до свого публічного ключа "B". Після цього він отримує нову точку на еліптичній кривій, яку він інтерпретує як публічний ключ "K0":

> K0 = B + s·G

Як тільки Боб має цей публічний ключ "K0", він може вивести асоційований приватний ключ, щоб витратити свої біткоїни. Він єдиний, хто може згенерувати цей номер.

- Боб додає свій похідний дочірній приватний ключ "b" зі свого особистого платіжного коду. Він єдиний, хто може отримати значення "b". Потім він додає "b" до спільного секрету "s", щоб отримати k0, приватний ключ K0:

> k0 = b + s
> Завдяки закону групи еліптичної кривої, Боб отримує точно приватний ключ, що відповідає публічному ключу, який використовувала Аліса. Отже, ми маємо:
> K0 = k0·G

![Боб генерує свої приймальні адреси BIP47](assets/24.webp)

Кредит: Reusable Payment Codes for Hierarchical Deterministic Wallets, Justus Ranvier. https://github.com/bitcoin/bips/blob/master/bip-0047.mediawiki

Якщо ми порівняємо цю діаграму з тим, що я вам раніше описав:

- "Child Priv-Key 0" з боку Боба відповідає: b.

- "Child Pub-Key 0" з боку Аліси відповідає: A.

- "Payment Secret 0" відповідає: s.

- "Payment Pub-Key 0" відповідає: K0.

- "Payment Priv-Key 0" відповідає: k0.

Дозвольте мені підсумувати кроки, які ми щойно розглянули разом, щоб отримати платіж BIP47 та обчислити відповідний приватний ключ:

- Боб вибирає перший похідний дочірній приватний ключ зі свого особистого платіжного коду.

- Він обчислює секретну точку на еліптичній кривій, використовуючи ECDH з першого похідного дочірнього публічного ключа з ланцюгового коду Аліси.

- Він використовує цю секретну точку, щоб обчислити спільний секрет за допомогою SHA256.

- Він використовує цей спільний секрет, щоб обчислити нову секретну точку на еліптичній кривій.

- Він додає цю нову секретну точку до свого особистого публічного ключа.

- Він отримує новий ефемерний публічний ключ, на який Аліса надішле свій перший платіж.

- Боб обчислює приватний ключ, асоційований з цим ефемерним публічним ключем, додаючи свій похідний дочірній приватний ключ зі свого платіжного коду та спільний секрет.

Оскільки Аліса не може отримати "b", приватний ключ Боба, вона не може визначити k0, приватний ключ, асоційований з приймальною адресою Боба BIP47.

Схематично ми можемо представити обчислення спільного секрету "S" так:

![Обчислення спільного секрету з ECDHE](assets/25.webp)

Як тільки спільний секрет знайдено за допомогою ECDH, Аліса та Боб обчислюють публічний ключ платежу BIP47 "K0", а Боб також обчислює асоційований приватний ключ "k0".
![Виведення адреси отримувача BIP47 з загального секрету](assets/26.webp)
### Повернення коштів за допомогою BIP47.

Оскільки Боб знає повторно використовуваний платіжний код Аліси, він вже має всю необхідну інформацію, щоб надіслати їй повернення коштів. Йому не потрібно буде зв'язуватися з Алісою, щоб запитати будь-яку інформацію. Він просто повідомить її за допомогою транзакції-повідомлення, особливо для того, щоб вона могла відновити свої адреси BIP47 за допомогою свого seed, а потім він також може надіслати їй до 2^32 платежів.
Таким чином, Боб може повернути Алісі кошти тим же способом, яким вона надсилала йому платежі. Ролі змінюються:

![Боб надсилає повернення коштів Алісі за допомогою BIP47](assets/27.webp)

Автор: Повторно використовувані платіжні коди для ієрархічно детермінованих гаманців, Justus Ranvier. https://github.com/bitcoin/bips/blob/master/bip-0047.mediawiki

Тепер ви знаєте всі тонкощі цього чудового рішення, яке представляє BIP47.

## Похідне використання PayNym.

Впровадження цього BIP47 у гаманець Samourai призвело до створення PayNyms, ідентифікаторів, розрахованих з платіжних кодів користувачів. Сьогодні їх корисність йде далеко за межі використання BIP47.

Команда Samourai поступово розробляє цілу екосистему інструментів та сервісів на основі PayNym користувача. Серед них, звичайно, є всі інструменти для витрат, які дозволяють оптимізувати конфіденційність користувача, додаючи ентропію до транзакції, і таким чином додаючи плаузибельне заперечення.

Спільне використання Soroban, зашифрованої мережі зв'язку на основі Tor, та PayNyms значно оптимізувало досвід користувача при створенні спільних транзакцій, зберігаючи при цьому хороший рівень безпеки. Таким чином, легко виконати транзакції Stowaway (PayJoin) та StonewallX2 без ручного виконання численних обмінів непідписаними транзакціями, необхідних для налаштування такої спільної транзакції.

На відміну від використання BIP47, оскільки ці спільні транзакції не вимагають транзакції-повідомлення, достатньо лише зв'язати PayNyms для використання цих інструментів. Немає потреби їх підключати.

Якщо ви хочете дізнатися більше про спільні транзакції та, ширше, про всі інструменти витрат гаманця Samourai, ви можете прочитати розділ "Інструменти витрат" у цій статті. Ви знайдете технічне пояснення та детальний підручник для кожного інструмента.

Крім цих спільних транзакцій, нещодавно було помічено, що команда Samourai працює над протоколом аутентифікації, пов'язаним з PayNym: Auth47. Цей інструмент вже впроваджено і дозволяє, наприклад, аутентифікацію за допомогою PayNym на вебсайті, який приймає цей метод. У майбутньому, я думаю, що, крім можливості аутентифікації в Інтернеті, Auth47 стане частиною більшого проекту навколо екосистеми BIP47/PayNym/Samourai. Можливо, цей протокол буде використовуватися для подальшої оптимізації досвіду користувача гаманця Samourai, особливо у використанні інструментів витрат. Побачимо...

## Моя особиста думка про BIP47.

Очевидно, головний недолік BIP47 - це транзакція-повідомлення. Вона змушує користувача витрачати кошти на її майнінг, що може бути неприємно для деяких. Однак аргумент про "спам" на блокчейні Bitcoin абсолютно неприйнятний. Кожен, хто платить комісію за свою транзакцію, повинен мати можливість записати її в реєстр, незалежно від її мети. Стверджувати інакше - це виступати за цензуру.

Можливо, у майбутньому будуть знайдені інші, менш дорогі рішення для передачі платіжного коду відправника одержувачу та для безпечного зберігання його одержувачем. Але наразі транзакція-повідомлення залишається рішенням з найменшими компромісами.
Цей недолік залишається незначним, якщо враховувати всі переваги BIP47. Серед усіх існуючих пропозицій щодо вирішення проблеми повторного використання адрес, вона здається мені найкращим рішенням.
Як було пояснено раніше, більшість випадків повторного використання адрес походить від бірж. BIP47 є єдиним розумним рішенням, яке насправді вирішує цю проблему у її джерелі. Будь-яка пропозиція, спрямована на зменшення кількості повторного використання адрес, повинна зосередитися на цьому аспекті та адаптувати рішення до основного джерела проблеми.

З точки зору зручності використання, хоча її внутрішня структура досить складна, процедура оплати BIP47 є простою. Тому повторно використовувані коди оплати можуть бути легко прийняті, навіть новачками.

З точки зору конфіденційності, BIP47 дуже цікавий. Як я пояснив у розділі про транзакцію повідомлення, платіжний код не розкриває жодної інформації про похідні ефемерні адреси. Таким чином, він перериває потік інформації між транзакцією Bitcoin та ідентифікатором одержувача, на відміну від традиційного використання адреси отримувача.

І головне, реалізація PayNym BIP47 працює! Вона доступна у Samourai Wallet з 2016 року та у Sparrow Wallet з початку цього року. Це не науковий проект, а рішення, яке було протестовано вчора і повністю функціональне сьогодні.

Сподіваюся, в майбутньому ці повторно використовувані платіжні коди будуть прийняті учасниками екосистеми, імплементовані в програмне забезпечення гаманців та використовувані біткойнерами.

Будь-яке справді позитивне рішення для конфіденційності користувачів має бути обговорене, просуване та захищене, щоб Bitcoin не став майданчиком для CA та інструментом спостереження урядів.
Він замислився про те, як його переслідували та ображали скрізь, а тепер він чув, що всі кажуть, що він найкрасивіший серед усіх цих прекрасних птахів! І навіть бузина нахилила свої гілки до нього, а сонце розповсюджувало таке тепле та благодатне світло! Тоді його пір'я розпушилося, його тендітна шия випросталася, і він вигукнув усім серцем: "Як я міг мріяти про таке щастя, коли був лише потворним маленьким каченям."

## Для подальшого вивчення:

- Розуміння та використання CoinJoin на Bitcoin.

- Розуміння шляхів похідності Bitcoin гаманця.

- Встановлення та використання вашого Bitcoin вузла RoninDojo.

### Зовнішні ресурси та подяки:

Дякую LaurentMT та Théo Pantamis за численні концепції, які вони мені пояснили, і які я використав у цій статті. Сподіваюся, я точно їх передав.

Дякую Fanis Michalakis за коректуру цього тексту та його експертні поради.

- https://bitcoiner.guide/paynym/
- https://github.com/bitcoin/bips/blob/master/bip-0047.mediawiki
- https://fr.wikipedia.org/wiki/%C3%89change_de_cl%C3%A9s_Diffie-Hellman
- https://fr.wikipedia.org/wiki/%C3%89change_de_cl%C3%A9s_Diffie-Hellman_bas%C3%A9_sur_les_courbes_elliptiques
- https://security.stackexchange.com/questions/46802/what-is-the-difference-between-dhe-and-ecdh#:~:text=The%20difference%20between%20DHE%20and%20ECDH%20in%20two%20bullet%20points,a%20type%20of%20algebraic%20curve).
- https://commandlinefanatic.com/cgi-bin/showarticle.cgi?article=art060
- https://ee.stanford.edu/~hellman/publications/24.pdf
- https://www.researchgate.net/publication/317339928_A_study_on_diffie-hellman_key_exchange_protocols