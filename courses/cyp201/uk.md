---
name: Вступ до криптографічних алгоритмів Bitcoin
goal: Зрозуміти створення гаманця Bitcoin з криптографічної перспективи
objectives:
  - Розвіяти термінологію криптографії, пов'язану з Bitcoin.
  - Оволодіти створенням гаманця Bitcoin.
  - Зрозуміти структуру гаманця Bitcoin.
  - Зрозуміти адреси та шляхи похідності.
---

# Подорож у світ криптографії

Чи захоплюєтеся ви Bitcoin? Цікавитеся, як працює гаманець Bitcoin? Готуйтеся до захоплюючої подорожі у світ криптографії! Лоїк, наш експерт, проведе вас через складнощі створення гаманця Bitcoin, розкриваючи таємниці залякувальних технічних термінів, таких як хешування, похідне ключа та еліптичні криві.

Це навчання не лише наділить вас знаннями для розуміння структури гаманця Bitcoin, але й підготує вас до глибшого занурення у захоплюючий світ криптографії. Отже, ви готові до цієї подорожі? Приєднуйтеся до нас і перетворіть вашу цікавість на експертизу!

+++

# Вступ
<partId>32960669-d13a-592f-a053-37f70b997cbf</partId>

## Вступ до криптографії
<chapterId>fb4e8857-ea35-5a8a-ae8a-5300234e0104</chapterId>

### Це навчання для вас? ТАК!

Ми раді вітати вас на новому курсі під назвою "Крипто 301: Вступ до криптографії та HD гаманців", який веде експерт у цій галузі, Лоїк Морель. Цей курс занурить вас у захоплюючий світ криптографії, фундаментальної дисципліни математики, яка забезпечує шифрування та безпеку ваших даних.

У нашому повсякденному житті, а особливо у сфері Bitcoin, криптографія відіграє вирішальну роль. Концепції, пов'язані з криптографією, такі як приватні ключі, публічні ключі, адреси, шляхи похідності, сід та ентропія, є основою використання та створення гаманця Bitcoin. Протягом цього курсу Лоїк детально пояснить, як генеруються приватні ключі та як вони пов'язані з адресами. Лоїк також присвятить годину поясненню математичних деталей еліптичних кривих. Крім того, ви зрозумієте, чому важливо використовувати HMAC SHA512 для захисту вашого гаманця та яка різниця між сідом та мнемонічною фразою.
Основна мета цього навчання - дати вам змогу зрозуміти технічні процеси, що беруть участь у створенні HD гаманця, та криптографічні методи, що використовуються. З роками гаманці Bitcoin еволюціонували, ставши легшими у використанні, безпечнішими та стандартизованими завдяки конкретним BIP. Лоїк допоможе вам зрозуміти ці BIP, щоб осягнути вибір, зроблений розробниками Bitcoin та криптографами. Як і всі навчання, що пропонуються нашим університетом, це навчання абсолютно безкоштовне та відкрите. Це означає, що ви вільні брати його та використовувати, як бажаєте. Ми з нетерпінням чекаємо на ваші відгуки в кінці цього захоплюючого курсу.

### Слово ваше, професоре!

Вітаю всіх, я Лоїк Морель, ваш провідник у цьому технічному дослідженні криптографії, що використовується у гаманцях Bitcoin.

Наша подорож починається з занурення у глибини криптографічних хеш-функцій. Разом ми розберемо внутрішню структуру незамінної SHA256 та дослідимо різні алгоритми, присвячені похідності.

Ми продовжимо нашу пригоду, розшифровуючи таємничий світ цифрових підписів. Ви дізнаєтесь, як магія еліптичних кривих застосовується до цих підписів, і ми висвітлимо, як розрахувати публічний ключ з приватного ключа. І, звичайно, ми зануримося у процес цифрового підпису.
Далі ми повернемося назад у часі, щоб побачити еволюцію гаманців Bitcoin, і зануримося в концепції ентропії та випадкових чисел. Ми розглянемо відому мнемонічну фразу, а також торкнемося парольної фрази. У вас навіть буде унікальна можливість створити сід з 128 бросків кубика!

З цим міцним фундаментом ми будемо готові до критичної частини: створення гаманця Bitcoin. Від народження сіду та майстер-ключа, до вивчення розширених ключів, і похідних пар дочірніх ключів, кожен крок буде детально розібраний. Ми також обговоримо структуру гаманця та шляхи похідності.

На завершення нашої подорожі ми розглянемо адреси Bitcoin. Ми пояснимо, як вони створюються і яку важливу роль вони відіграють у функціонуванні гаманців Bitcoin.

Приєднуйтесь до мене в цій захоплюючій подорожі, і будьте готові дослідити світ криптографії як ніколи раніше. Залиште свої попередні уявлення за дверима і відкрийте свій розум для нового способу розуміння Bitcoin та його фундаментальної структури.

# Хеш-функції
<partId>3713fee1-2ec2-512e-9e97-b6da9e4d2f17</partId>

## Вступ до криптографічних хеш-функцій, пов'язаних з Bitcoin
<chapterId>dba011f5-1805-5a48-ac2b-4bd637c93703</chapterId>

Ласкаво просимо на сьогоднішнє заняття, присвячене глибокому зануренню в криптографічний світ хеш-функцій, ключового каменя безпеки протоколу Bitcoin. Уявіть хеш-функцію як ультраефективного криптографічного дешифрувального робота, який перетворює інформацію будь-якого розміру на унікальний і фіксований за розміром цифровий відбиток, званий "хеш", "дайджест" або "контрольна сума".
Підсумовуючи, хеш-функція бере вхідне повідомлення довільного розміру і перетворює його на вихідний відбиток фіксованого розміру.

Опис профілю криптографічних хеш-функцій вимагає розуміння двох основних якостей: їх незворотності та їх стійкості до підробки.

Незворотність, або стійкість до прямого зображення, означає, що обчислення виходу за входом може бути зроблено легко, але обчислення входу за виходом є неможливим.
Це одностороння функція.

![зображення](assets/image/section1/0.webp)

Стійкість до підробки випливає з того факту, що навіть найменша зміна входу призведе до глибоко відмінного виходу.
Ці функції дозволяють перевіряти цілісність завантаженого програмного забезпечення.

![зображення](assets/image/section1/1.webp)

Іншою важливою характеристикою, якою вони володіють, є їх стійкість до колізій та другого прямого зображення. Колізія виникає, коли два різні входи виробляють однаковий вихід.
Звичайно, у всесвіті хешування колізії неминучі, але відмінна криптографічна хеш-функція мінімізує їх значно. Ризик повинен бути настільки низьким, що його можна вважати незначним. Це так, ніби кожен хеш є будинком у величезному місті; незважаючи на величезну кількість будинків, хороша хеш-функція забезпечує унікальну адресу кожного будинку.

Стійкість до другого прямого зображення залежить від стійкості до колізій; якщо є стійкість до колізій, то є стійкість і до другого прямого зображення.
Маючи вхідну інформацію, яка нам нав'язана, ми повинні знайти другий вхід, відмінний від першого, який виробляє колізію у вихідному хеші функції. Стійкість до другого прямого зображення схожа на стійкість до колізій, за винятком того, що вхід нав'язаний.
Давайте тепер зануримося в бурхливі води застарілих хеш-функцій. SHA0, SHA1 та MD5 зараз вважаються іржавими оболонками в океані криптографічного хешування. Їх часто не рекомендують, оскільки вони втратили свою стійкість до колізій. Принцип голуб'ятні пояснює, чому, незважаючи на наші кращі зусилля, уникнення колізій неможливе через обмеження розміру виходу. Щоб дійсно вважатися безпечною, хеш-функція має бути стійкою до колізій, других преімаджів та преімаджів.

Ключовим елементом в протоколі Bitcoin є хеш-функція SHA-256, яка є капітаном корабля. Інші функції, такі як SHA-512, використовуються для похідних з HMAC та PBKDF. Крім того, RIPMD160 використовується для зменшення відбитка до 160 біт. Коли ми говоримо про HASH256 та HASH160, ми маємо на увазі використання подвійного хешування з SHA-256 та RIPMD.

Для HASH256 це подвійний хеш повідомлення за допомогою функції SHA256.
$$
SHA256(SHA256(повідомлення))
$$
Для HASH160 це подвійний хеш повідомлення спочатку за допомогою SHA256, а потім RIPMD160.
$$
RIPMD160(SHA256(повідомлення))
$$
Використання HASH160 особливо вигідне, оскільки це дозволяє забезпечити безпеку SHA-256, зменшуючи розмір відбитка.

Підсумовуючи, основна мета криптографічної хеш-функції полягає в перетворенні інформації довільного розміру на відбиток фіксованого розміру. Щоб вважатися безпечною, вона повинна мати кілька переваг: незворотність, стійкість до втручань, стійкість до колізій та стійкість до других преімаджів.

![зображення](assets/image/section1/2.webp)

На кінці цього дослідження ми розкрили таємниці криптографічних хеш-функцій, висвітлили їх використання в протоколі Bitcoin та проаналізували їх конкретні цілі. Ми дізналися, що для того, щоб хеш-функції вважалися безпечними, вони повинні бути стійкими до преімаджів, других преімаджів, колізій та втручань. Ми також охопили ряд різних хеш-функцій, що використовуються в протоколі Bitcoin. У нашій наступній сесії ми поглибимося в ядро функції хешування SHA256 та відкриємо захоплюючу математику, яка надає їй унікальні характеристики.

## Внутрішня робота SHA256
<chapterId>905eb320-f15b-5fb6-8d2d-5bb447337deb</chapterId>

Ласкаво просимо до продовження нашої захоплюючої подорожі через криптографічні лабіринти хеш-функції. Сьогодні ми розкриваємо таємниці SHA256, складного, але геніального процесу, про який ми говорили раніше.

Нагадуємо, що мета хеш-функції SHA256 полягає в тому, щоб прийняти вхідне повідомлення будь-якого розміру та згенерувати 256-бітний хеш як вихід.

### Попередня обробка

Давайте зробимо крок далі в цьому лабіринті, почавши з попередньої обробки SHA256.

#### Додавання бітів

Мета цього першого кроку полягає в тому, щоб мати повідомлення, яке дорівнює кратному 512 бітам. Для досягнення цього ми додамо біти доповнення до повідомлення.

Нехай M буде початковим розміром повідомлення.
Нехай 1 буде бітом, зарезервованим для роздільника.
Нехай P буде кількістю бітів, використаних для доповнення, а 64 - кількістю бітів, відведених для другої фази попередньої обробки.
Загальна кількість повинна бути кратною 512 бітам, що представлено n.

![зображення](assets/image/section1/3.webp)

Приклад з вхідним повідомленням 950 біт:

```
Крок 1: Визначте розмір; бажана кінцева кількість бітів.
Перший кратний 512 > (M + 64 + 1) (де M = 950) це 1024. 1024 = 2 * 512
Отже, n = 2.

Крок 2: Визначте P, кількість бітів доповнення, необхідних для досягнення бажаної кількості бітів.
-> M + 1 + P + 64 = n * 512
-> M + 1 + P + 64 = 2 * 512
-> 950 + 1 + P + 64 = 1024
-> P = 1024 - 1 - 64 - 950
-> P = 9

Отже, потрібно додати 9 бітів доповнення, щоб повідомлення відповідало кратному 512.

```
Повідомлення + 1 000 000 000
```

#### Доповнення розміру

Тепер ми переходимо до другої фази попередньої обробки, яка включає додавання двійкового представлення розміру початкового повідомлення в бітах.

Повернемося до прикладу з вхідними даними в 950 біт:

```
Двійкове представлення числа 950: 11 1011 0110

Ми використовуємо наші 64 зарезервовані біти з попереднього кроку. Ми додаємо нулі, щоб округлити наші 64 біти до нашого вирівняного вводу. Потім ми об'єднуємо початкове повідомлення, біти доповнення та доповнення розміру, щоб отримати наш вирівняний ввід.
```

Ось результат:

![зображення](assets/image/section1/4.webp)

### Обробка

#### Розуміння передумов

##### Константи та вектори ініціалізації

Тепер ми готуємося до початкових кроків обробки функції SHA-256. Як і в будь-якому хорошому рецепті, нам потрібні деякі базові інгредієнти, які ми називаємо константами та векторами ініціалізації.

Вектори ініціалізації, від A до H, є першими 32 бітами десяткових частин квадратних коренів перших 8 простих чисел. Вони слугуватимуть базовими значеннями на початкових етапах обробки. Їхні значення у шістнадцятковому форматі.

Константи K, від 0 до 63, представляють перші 32 біти десяткових частин кубічних коренів перших 64 простих чисел. Вони використовуються в кожному раунді функції стиснення. Їхні значення також у шістнадцятковому форматі.

![зображення](assets/image/section1/5.webp)

##### Використані операції

У функції стиснення ми використовуємо специфічні оператори, такі як XOR, AND та NOT. Ми обробляємо біти один за одним згідно з їхнім положенням, використовуючи оператор XOR та таблицю істинності. Оператор AND використовується для повернення 1, лише якщо обидва операнди дорівнюють 1, а оператор NOT використовується для повернення протилежного значення операнда. Ми також використовуємо операцію SHR для зсуву бітів вправо на обрану кількість.

Таблиця істинності:

![зображення](assets/image/section1/6.webp)

Операції зсуву бітів:

![зображення](assets/image/section1/7.webp)

#### Функція стиснення

Перед застосуванням функції стиснення ми ділимо вхід на блоки по 512 біт. Кожен блок обробляється незалежно від інших.

Кожен 512-бітний блок потім поділяється на 32-бітні частини, які називаються W. Таким чином, W(0) представляє перші 32 біти 512-бітного блоку. W(1) представляє наступні 32 біти, і так далі, поки ми не досягнемо 512 бітів блоку.
Як тільки всі константи K та чанки W визначені, ми можемо виконати наступні обчислення для кожного чанка W в кожному раунді.
Ми виконуємо 64 раунди обчислень у функції стиснення. У останньому раунді, на рівні "Вихід функції", ми матимемо проміжний стан, який буде доданий до початкового стану функції стиснення.

Потім ми повторюємо всі ці кроки функції стиснення на наступному 512-бітному блоку, доки не дійдемо до останнього блоку.

Всі додавання у функції стиснення є додаваннями за модулем 2^32, щоб завжди зберігати 32-бітну суму.

![зображення](assets/image/section1/9.webp)

![зображення](assets/image/section1/8.webp)

##### Один раунд функції стиснення

![зображення](assets/image/section1/11.webp)

![зображення](assets/image/section1/10.webp)

Функція стиснення буде виконана 64 рази. Ми маємо наші частини W та наші попередньо визначені константи K як вхід.
Червоні квадрати/хрести відповідають додаванню за модулем 2^32 біт.

Вхідні дані A, B, C, D, E, F, G, H будуть асоційовані з 32-бітним значенням, щоб утворити загалом 32 * 8 = 256 біт.
Ми також маємо нову послідовність A, B, C, D, E, F, G, H як вихід. Цей вихід потім буде використаний як вхід для наступного раунду і так далі до кінця 64-го раунду.

Значення вхідної послідовності для першого раунду функції стиснення відповідають попередньо визначеним векторам ініціалізації, згаданим раніше.
Нагадуємо, що вектори ініціалізації представляють перші 32 біти десяткових частин квадратних коренів перших 8 простих чисел.

Ось приклад раунду:

![зображення](assets/image/section1/12.1.webp)

##### Проміжний стан

Нагадуємо, що повідомлення ділиться на блоки по 512 біт, які потім діляться на 32-бітні частини. Для кожного 512-бітного блоку ми застосовуємо 64 раунди функції стиснення.
Проміжний стан відповідає кінцю 64 раундів блоку. Значення вихідної послідовності з цього 64-го раунду використовуються як початкові значення для вхідної послідовності першого раунду наступного блоку.

![зображення](assets/image/section1/12.2.webp)

#### Огляд хеш-функції

![зображення](assets/image/section1/13.webp)

Ми можемо помітити, що вихід першої 512-бітної частини повідомлення відповідає нашим векторам ініціалізації як вхід для другої 512-бітної частини повідомлення, і так далі.

Вихід останнього раунду, останньої частини, відповідає кінцевому результату функції SHA256.

На завершення, ми хотіли б підкреслити критичну роль обчислень, виконаних у блоках CH, MAJ, σ0, і σ1. Ці операції, серед інших, є стражами, які забезпечують міцність хеш-функції SHA256 проти атак, роблячи її переважним вибором для захисту багатьох цифрових систем, особливо в протоколі Bitcoin. Це очевидно, що, хоча і складно, краса SHA256 полягає в її здатності знайти вхід з хешу, тоді як перевірка хешу для даного входу є механічно простою дією.

## Алгоритми, що використовуються для похідної
<chapterId>cc668121-7789-5e99-bf5e-1ba085f4f5f2</chapterId>
Алгоритми HMAC та PBKDF2 є ключовими компонентами механізму безпеки протоколу Bitcoin. Вони запобігають різноманітним потенційним атакам та забезпечують цілісність гаманців Bitcoin. HMAC та PBKDF2 - це криптографічні інструменти, що використовуються для різних завдань у Bitcoin. HMAC переважно використовується для протидії атакам на розширення довжини при виведенні ієрархічних детермінованих (HD) гаманців, тоді як PBKDF2 використовується для перетворення мнемонічної фрази в сід.

#### HMAC-SHA512

Пара HMAC-SHA512 має два входи: повідомлення m (Вхід 1) та ключ K, довільно обраний користувачем (Вхід 2). Вона також має фіксований розмір виходу: 512 біт.

Зауважимо:
- m: повідомлення довільного розміру, обране користувачем (вхід 1)
- K: довільний ключ, обраний користувачем (вхід 2)
- K': уніфікований ключ K. Він був скоригований до розміру B блоків.
- ||: операція конкатенації.
- opad: константа, визначена байтом 0x5c, повторена B разів.
- ipad: константа, визначена байтом 0x36, повторена B разів.
- B: Розмір блоків хеш-функції, що використовується.

![image](assets/image/section1/14.webp)

HMAC-SHA512, який бере повідомлення та ключ як входи, генерує фіксований розмір виходу. Для забезпечення уніформності, ключ коригується на основі розміру блоків, що використовуються в хеш-функції. У контексті виведення HD гаманців використовується HMAC-SHA-512. Він працює з 1024-бітними (128-байтними) блоками та відповідно коригує ключ. Використовуються константи OPAD (0x5c) та IPAD (0x36), повторені за необхідності для підвищення безпеки.

Процес HMAC-SHA-512 включає конкатенацію результату SHA-512, застосованого до ключа XOR OPAD та ключа XOR IPAD з повідомленням. При використанні з 1024-бітними (128-байтними) блоками, вхідний ключ за необхідності доповнюється нулями, потім XOR'ується з IPAD та OPAD. Модифікований ключ потім конкатенується з повідомленням.

![image](assets/image/section1/15.webp)

Включення солі в код рядка збільшує безпеку похідних ключів. Без неї атака могла б скомпрометувати весь гаманець та вкрасти всі біткоїни.

PBKDF2 використовується для перетворення мнемонічної фрази в сід. Цей алгоритм виконує 2048 раундів, використовуючи HMAC SHA512. За допомогою цих алгоритмів похідної, різні входи можуть виробляти унікальний та фіксований вихід, що пом'якшує проблему можливих атак на розширення довжини на функції сімейства SHA-2.
Атака на розширення довжини використовує специфічну властивість певних криптографічних хеш-функцій. У такій атаці, нападник, який вже має хеш невідомого повідомлення, може використовувати його для розрахунку хешу довшого повідомлення, яке є розширенням оригінального повідомлення. Це часто можливо без знання змісту оригінального повідомлення, що може призвести до значних вразливостей безпеки, якщо такий тип хеш-функції використовується для завдань, таких як перевірка цілісності.

![image](assets/image/section1/16.webp)

На завершення, алгоритми HMAC та PBKDF2 відіграють суттєві ролі у безпеці похідної HD гаманця в протоколі Bitcoin. HMAC-SHA-512 використовується для захисту від атак на розширення довжини, тоді як PBKDF2 дозволяє перетворення мнемонічної фрази в сід. Код рядка додає додаткове джерело ентропії у похідному ключі, забезпечуючи міцність системи.

# Цифрові Підписи
<partId>76b58a00-0c18-54b9-870d-6b7e34029db8</partId>
## Цифрові підписи та еліптичні криві
<chapterId>c9dd9672-6da1-57f8-9871-8b28994d4c1a</chapterId>

Де зберігаються ці відомі біткойни? Не в гаманці Bitcoin, як можна було б подумати. Насправді, Bitcoin гаманець зберігає приватні ключі, необхідні для доведення власності на біткойни. Самі біткойни записані в блокчейні, децентралізованій базі даних, яка архівує всі транзакції.

У системі Bitcoin одиницею обліку є біткойн (зверніть увагу на маленьку "b"). Він ділиться до восьми десяткових місць, при цьому найменша одиниця - це сатоші. UTXO, або "Невитрачені Вихідні Транзакції", представляють невитрачені вихідні транзакції, які належать публічному ключу, математично пов'язаному з приватним ключем. Для витрати цих біткойнів, необхідно виконати умову витрати транзакції. Типова умова витрати включає доведення решті мережі, що користувач є законним власником публічного ключа, асоційованого з UTXO. Для цього користувач має продемонструвати володіння приватним ключем, що відповідає публічному ключу, пов'язаному з кожним UTXO, не розкриваючи приватний ключ.

Ось де з'являється цифровий підпис. Він служить математичним доказом володіння приватним ключем, асоційованим з певним публічним ключем. Ця техніка захисту даних головним чином базується на захоплюючій галузі криптографії, яка називається криптографією на еліптичних кривих (ECC).

Підпис може бути математично перевірений іншими учасниками мережі Bitcoin.

![image](assets/image/section2/0.webp)

Для забезпечення безпеки транзакцій, Bitcoin покладається на два протоколи цифрових підписів: ECDSA (Алгоритм Цифрового Підпису на Еліптичних Кривих) та Schnorr. ECDSA був інтегрований у протокол Bitcoin з моменту його запуску в 2009 році, тоді як підписи Schnorr були додані нещодавно, у листопаді 2021 року. Хоча обидва протоколи базуються на криптографії еліптичних кривих і використовують схожі математичні механізми, вони головним чином відрізняються за структурою підпису.

У цьому курсі ми представимо алгоритм ECDSA.

### Що таке еліптична крива?

Криптографія на еліптичних кривих - це набір алгоритмів, які використовують еліптичну криву за її різноманітні геометричні та математичні властивості в криптографічному контексті, з безпекою, що базується на складності обчислення дискретного логарифму.

Еліптичні криві корисні в різноманітних криптографічних застосуваннях у протоколі Bitcoin, від обміну ключами до асиметричного шифрування та цифрових підписів.

Еліптичні криві мають цікаві властивості:

- Симетрія: будь-яка не вертикальна лінія, що перетинає дві точки на еліптичній кривій, перетне криву в третій точці.
- Будь-яка не вертикальна лінія, що дотикається до кривої в точці, завжди перетне криву в унікальній другій точці.

Протокол Bitcoin використовує специфічну еліптичну криву під назвою Secp256k1 для своїх криптографічних операцій.

Перед тим, як глибше зануритися в ці механізми підпису, важливо зрозуміти, що таке еліптична крива. Еліптична крива визначається рівнянням y² = x³ + ax + b. Кожна точка на цій кривій має виразну симетрію, яка є ключовою для її корисності в криптографії.

![image](assets/image/section2/1.webp)

Врешті-решт, різні еліптичні криві визнані безпечними для криптографічного використання. Найвідомішою може бути крива secp256r1. Однак для Bitcoin, Сатоші Накамото обрав іншу криву: secp256k1.
Ця крива визначена параметрами a=0 та b=7, і її рівняння y² = x³ + 7 за модулем n, де n представляє просте число, яке визначає порядок кривої.
![image](assets/image/section2/2.webp)

Перше зображення представляє криву secp256k1 над дійсним полем та її рівняння.
Друге зображення є представленням кривої secp256k1 над полем ZP, полем додатних натуральних чисел, за модулем p, де p є простим числом. Воно виглядає як хмара точок. Ми використовуємо це поле додатних натуральних чисел, щоб уникнути наближень.
p є простим числом, і це порядок кривої, який використовується.
Нарешті, рівняння, яке використовується в протоколі Bitcoin, є:$$
y^2 = (x^3 + 7) mod(p) $$
Рівняння еліптичної кривої в Bitcoin відповідає останньому рівнянню на попередньому зображенні.

У наступному розділі цього курсу ми будемо використовувати криві, які знаходяться на дійсному полі, просто для спрощення розуміння.

## Обчислення публічного ключа з приватного ключа
<chapterId>fcb2bd58-5dda-5ecf-bb8f-ad1a0561ab4a</chapterId>

Для початку, давайте зануримося в світ алгоритму цифрового підпису на еліптичних кривих (ECDSA). Bitcoin використовує цей алгоритм цифрового підпису для зв'язування приватних і публічних ключів. У цій системі приватний ключ є випадковим або псевдовипадковим 256-бітним числом. Теоретично кількість можливостей для приватного ключа становить 2^256, але насправді вона трохи менша. Більш точно, деякі 256-бітні приватні ключі не є дійсними для Bitcoin.

Щоб бути сумісним з Bitcoin, приватний ключ має бути між 1 та n-1, де n представляє порядок еліптичної кривої. Це означає, що загальна кількість можливостей для приватного ключа Bitcoin майже дорівнює 1.158 x 10^77. Для порівняння, це приблизно та сама кількість атомів, що присутні в спостережуваній Всесвіті.

![image](assets/image/section2/3.webp)

Унікальний приватний ключ, позначений як k, потім використовується для визначення публічного ключа.

Публічний ключ, позначений як K, є точкою на еліптичній кривій, яка отримана з приватного ключа за допомогою незворотних алгоритмів, таких як ECDSA. Коли ми маємо знання про приватний ключ, дуже легко отримати публічний ключ, але коли ми маємо лише публічний ключ, неможливо отримати приватний ключ. Ця незворотність є кутовим каменем безпеки гаманця Bitcoin.

Публічний ключ має довжину 512 біт, оскільки він відповідає точці на кривій з x-координатою 256 біт і y-координатою 256 біт. Однак, його можна стиснути до 264-бітного числа.

![image](assets/image/section2/4.webp)

Точка генератора (G) є точкою на кривій, з якої генеруються всі публічні ключі в протоколі Bitcoin. Вона має специфічні x та y координати, зазвичай представлені в шістнадцятковому форматі. Для secp256k1 координати G у шістнадцятковому форматі:

- `Gx = 79BE667E F9DCBBAC 55A06295 CE870B07 029BFCDB 2DCE28D9 59F2815B 16F81798`
- `Gy = 483ADA77 26A3C465 5DA4FBFC 0E1108A8 FD17B448 A6855419 9C47D08F FB10D4B8` Ця точка корисна для виведення всіх публічних ключів. Щоб розрахувати публічний ключ K, просто помножте точку G на приватний ключ k, таким чином: K = k.G

Тепер ми вивчимо, як додавати та множити точки на еліптичних кривих.

#### Додавання та подвоєння точок на еліптичних кривих

##### Додавання двох точок M + L

Однією з видатних властивостей еліптичних кривих є те, що невертикальна лінія, яка перетинає криву в двох точках, також перетне її в третій точці, яку в нашому прикладі називають точкою O. Ця властивість використовується для визначення точки U, яка є протилежною до точки O.

M + L = U

![зображення](assets/image/section2/5.webp)

##### Додавання точки до самої себе = Подвоєння точки

Додавання точки G до самої себе виконується шляхом проведення дотичної до кривої в цій точці. Ця дотична, згідно з властивостями еліптичних кривих, перетне криву в другій унікальній точці -J. Протилежна цій точці, J, є результатом додавання точки G до самої себе.
G + G = J

Насправді, точка G є вихідною точкою для розрахунку всіх публічних ключів користувачів системи Bitcoin.

![зображення](assets/image/section2/6.webp)

#### Скалярне множення на еліптичних кривих

Скалярне множення точки на n еквівалентне додаванню цієї точки до самої себе n разів.

Аналогічно подвоєнню точки, скалярне множення точки G на точку n виконується шляхом проведення дотичної до кривої в точці G. Ця дотична, згідно з властивостями еліптичних кривих, перетне криву в другій унікальній точці -2G. Протилежна цій точці, 2G, є результатом додавання точки G до самої себе.

Якщо n = 4, то операція повторюється до досягнення 4G.

![зображення](assets/image/section2/7.webp)

Ось приклад розрахунку для 3G:

![зображення](assets/image/section2/8.webp)

Ці операції з точками на еліптичній кривій є основою для розрахунку публічних ключів. Виведення публічного ключа, знаючи приватний ключ, дуже просте.
Публічний ключ - це точка на еліптичній кривій, вона є результатом нашого додавання та подвоєння точки G k разів. З k = приватний ключ.

У цьому прикладі:

- Приватний ключ k = 4
- Публічний ключ K = kG = 4G

![зображення](assets/image/section2/9.webp)

Знаючи приватний ключ k, легко розрахувати публічний ключ K. Однак, неможливо відновити приватний ключ на основі публічного ключа. Це результат додавання чи подвоєння точок?

У нашому наступному уроці ми дослідимо, як створюється цифровий підпис за допомогою алгоритму ECDSA з приватним ключем для витрачання біткойнів.

## Підписання приватним ключем
<chapterId>bb07826f-826e-5905-b307-3d82001fb778</chapterId>

Процес цифрового підпису є ключовим методом доведення, що ви є власником приватного ключа, не розкриваючи його. Це досягається за допомогою алгоритму ECDSA, який включає визначення унікального nonce, розрахунок специфічного числа V, та створення цифрового підпису, що складається з двох частин, S1 та S2.
Це критично важливо завжди використовувати унікальний nonce, щоб уникнути атак на безпеку. Знаменитий приклад того, що може статися, коли це правило не дотримується, - це злам PlayStation 3, який був скомпрометований через повторне використання nonce.
![](assets/image/section2/10.webp)

Кроки:

- Визначте nonce v, який є унікальним випадковим числом.
  Nonce = Number Only Used Once (Число, що використовується лише один раз).
  Його визначає той, хто виконує підпис.
- Розрахуйте, додаючи та подвоюючи точки на еліптичній кривій від точки G, позицію V на еліптичній кривій.
  Таким чином V = v.G
  x та y - координати V на площині.
- Розрахуйте S1.
  S1 = x mod n, де n = порядок кривої, а x - координата V на площині.
  Зауважте: Кількість можливих публічних ключів більша, ніж кількість точок на еліптичній кривій у скінченному полі додатних цілих чисел, що використовується в Bitcoin.
  Порядок кривої відповідає лише можливостям, які публічний ключ може приймати на кривій.
- Розрахуйте S2.
  H(Tx) = Хеш транзакції
  k = приватний ключ
- Розрахуйте підпис: конкатенація S1 + S2.
- Розрахуйте P, розрахунок перевірки підпису.
  K = публічний ключ

Наприклад, щоб отримати публічний ключ 3G, ви проводите дотичну до точки G, розраховуєте протилежність -G, щоб отримати 2G, а потім додаєте G та 2G. Для виконання транзакції вам потрібно довести, що ви знаєте число 3, розблокувавши біткоїни, асоційовані з публічним ключем 3G.

Щоб створити цифровий підпис та довести, що ви знаєте приватний ключ, асоційований з публічним ключем 3G, ви спочатку розраховуєте nonce, потім точку V, асоційовану з цим nonce (у даному прикладі це 4G). Потім ви розраховуєте точку T, додаючи публічний ключ 3G та точку V, що дає 7G.

![image](assets/image/section2/11.webp)

Давайте спростимо процес цифрового підпису.
На попередньому зображенні приватний ключ k = 3.
Ми можемо легко розрахувати публічний ключ K, асоційований з цим приватним ключем: K = 3G.
Потім ми генеруємо nonce псевдовипадковим чином: v = 4.
З цього nonce можливо розрахувати V таким чином: V = v.G = 4G.

З цієї точки V ми розраховуємо точку T таким чином:
T = t.G = 7G (де t = 7).

Тепер настав час приступити до перевірки цифрового підпису.

Перевірка цифрового підпису є критично важливим кроком у використанні алгоритму ECDSA, який дозволяє підтвердити автентичність підписаного повідомлення без необхідності приватного ключа відправника. Ось як це працює детально:

У нашому прикладі ми маємо два важливі значення: t та V.
t - це числове значення (7 у цьому прикладі), а V - точка на еліптичній кривій (представлена тут як 4G). Ці значення генеруються під час створення цифрового підпису та потім надсилаються разом з повідомленням для можливості перевірки.

Коли верифікатор отримує повідомлення, він також отримує ці два значення, t та V.

Ось кроки, які верифікатор виконає для валідації підпису:

1. Спочатку вони розрахують хеш повідомлення, який ми назвемо H.
2. Потім вони розрахують u1 та u2. Для цього вони використають наступні формули:
- u1 = H /\* (S2)^-1 mod n   - u2 = T /\* (S2)^-1 mod n
     Де S2 - це друга частина цифрового підпису, n - порядок еліптичної кривої, а (S2)^-1 - це обернене до S2 за модулем n.
3. Перевіряючий потім обчислює точку P' на еліптичній кривій, використовуючи формулу: P' = u1 _ G + u2 _ K
   - G - це генераторна точка кривої
   - K - це публічний ключ відправника
4. Перевіряючий потім обчислює I', яке є просто x-координатою точки P' за модулем n.
5. Нарешті, перевіряючий підтверджує, що I' дорівнює t. Якщо це так, підпис вважається дійсним. Якщо ні, підпис є недійсним.
Ця процедура забезпечує, що лише відправник, який володіє відповідним приватним ключем, міг би створити підпис, який проходить цей процес перевірки.

![зображення](assets/image/section2/12.webp)

Простіше кажучи:
Особа, яка створює підпис, надає число t (у нашому прикладі, t = 7) та точку V особі, яка його перевіряє.

Неможливо визначити публічний або приватний ключ з числа 7 та числа V.

Кроки для перевірки цифрового підпису наступні:

- На кривій перевіряючий додає точку публічного ключа до точки V, щоб отримати точку T'.
- Перевіряючий обчислює число t.G.
- Перевіряючий перевіряє, що результат t.G дійсно дорівнює числу T'.

Висновок: перевірка цифрового підпису є суттєвою процедурою в транзакціях Bitcoin. Вона забезпечує, що підписане повідомлення не було змінено під час передачі та що відправник дійсно є власником приватного ключа. Ця техніка цифрової автентифікації базується на складних математичних принципах, включаючи арифметику еліптичних кривих, одночасно зберігаючи конфіденційність приватного ключа. Вона забезпечує міцну основу безпеки для криптографічних транзакцій.

Однак, управління цими ключами, а також їх створення, є ще одним суттєвим питанням у Bitcoin. Як генерувати нову пару ключів? Як безпечно та ефективно організувати безліч ключів? Як їх відновити за потреби?

Щоб відповісти на ці питання та поглибити ваше розуміння безпеки криптографії, наш наступний курс буде зосереджений на концепції Ієрархічних Детермінованих Гаманців (HD гаманців) та використанні мнемонічних фраз. Ці механізми пропонують елегантні способи ефективного управління вашими криптовалютними ключами, одночасно підвищуючи безпеку.

# Мнемонічна фраза
<partId>4070af16-c8a2-58b5-9871-a22c86c07458</partId>

## Еволюція гаманців Bitcoin
<chapterId>9d9acd5d-a0e5-5dfd-b544-f043fae8840f</chapterId>

Ієрархічний Детермінований Гаманець, більш відомий як HD гаманець, відіграє видатну роль в екосистемі криптовалют. Термін "гаманець" може здатися вводящим в оману для тих, хто новий у цій галузі, оскільки він не передбачає зберігання грошей або валют. Натомість він відноситься до колекції криптографічних приватних ключів.

Ранні гаманці були програмним забезпеченням, яке групувало приватні ключі в псевдовипадковому порядку, але не мало між ними зв'язку. Такі гаманці називають "Просто Набір Ключів" (JBOK).

Оскільки ключі не мають між собою зв'язку, користувач змушений робити новий бекап для кожної нової пари ключів, яку генерує.
Чи користувач завжди використовує ту саму пару ключів і компрометує конфіденційність, чи генерує нову пару ключів випадковим чином і тому потребує зробити новий бекап цих ключів.
Проте, складність управління цими ключами компенсується набором протоколів, які називаються Пропозиціями щодо Покращення Bitcoin (BIPs). Ці пропозиції оновлень лежать в основі функціональності та безпеки HD гаманців. Наприклад, [BIP32](https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki), запущений у 2012 році, кардинально змінив спосіб генерації та зберігання цих ключів, введенням концепції детерміновано та ієрархічно похідних ключів. Ідея полягає в тому, щоб отримувати всі ключі детерміновано та ієрархічно з унікального шматка інформації: seed (початкового значення). Це значно спрощує процес резервного копіювання цих ключів, зберігаючи при цьому їх рівень безпеки.
Після цього, [BIP39](https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki) ввів значне нововведення: 24-слівну мнемонічну фразу. Ця система перетворила складну та важку для запам'ятовування послідовність чисел на серію звичайних слів, роблячи її набагато легшою для запам'ятовування та зберігання. Крім того, [BIP38](https://github.com/bitcoin/bips/blob/master/bip-0038.mediawiki) запропонував додавання додаткової парольної фрази для підвищення безпеки індивідуальних ключів. Ці послідовні покращення призвели до стандартів BIP43 та BIP44, які стандартизували структуру та ієрархізацію HD гаманців, роблячи їх більш доступними та зручними для загального користувача.

У наступних розділах ми глибше зануримося в принципи роботи HD гаманців. Ми обговоримо принципи похідності ключів та розглянемо фундаментальні концепції ентропії та генерації випадкових чисел, які є важливими для забезпечення безпеки вашого HD гаманця.

Підсумовуючи, важливо виокремити центральну роль BIP32 та BIP39 у дизайні та безпеці HD гаманців. Ці протоколи дозволяють генерувати кілька ключів з одного seed, який має бути випадковим або псевдовипадковим числом. Сьогодні ці стандарти прийняті більшістю криптовалютних гаманців, незалежно від того, присвячені вони одній криптовалюті чи підтримують кілька типів валют.

## Ентропія та Генерація Випадкових Чисел
<chapterId>b43c715d-affb-56d8-a697-ad5bc2fffd63</chapterId>

Важливість безпеки приватних ключів у екосистемі Bitcoin є незаперечною. Вони дійсно є каменем основи, який забезпечує безпеку транзакцій Bitcoin. Щоб уникнути будь-якої вразливості, пов'язаної з передбачуваністю, ці ключі мають генеруватися у справді випадковому порядку, що може швидко стати клопіткою вправою. Проблема полягає в тому, що в комп'ютерних науках неможливо згенерувати справді випадкове число, оскільки воно обов'язково походить з детермінованого процесу; коду. Саме тому важливо дізнатися про різні Генератори Випадкових Чисел (RNG). Типи RNG варіюються від Псевдо-Випадкових Генераторів Чисел (PRNG) до Справжніх Генераторів Випадкових Чисел (TRNG), а також PRNG, які включають джерело ентропії.

Ентропія відноситься до стану "розладу" системи. З зовнішньої ентропії, тобто зовнішнього джерела інформації, можливо використовувати генератор випадкових чисел для отримання випадкового числа.

![image](assets/image/section3/2.webp)

Давайте подивимося, як працює Псевдо-Випадковий Генератор Чисел (PRNG).

Він бере на вхід seed, який відповідає внутрішньому стану 0.
На цьому внутрішньому стані застосовується функція перетворення, і результат, який є псевдо-випадковим числом, відповідає внутрішньому стану 1.
На цьому внутрішньому стані 1, знову застосовується функція перетворення, що призводить до нового випадкового числа = внутрішньому стану 2.
І так далі.
Основним недоліком є те, що будь-яке ідентичне початкове значення завжди вироблятиме однаковий результат. Також, якщо ми знаємо результат початкових функцій перетворення, ми зможемо відновити випадкове число на виході процесу.
Прикладом функції перетворення є функція PBKDF2.

**Підсумовуючи, криптографічно безпечний ГВЧП (генератор випадкових чисел) повинен:**

- бути статистично випадковим
- бути непередбачуваним
- бути стійким, навіть якщо результати будуть розкриті
- мати достатньо довгий період

![зображення](assets/image/section3/3.webp)

У випадку з Bitcoin, приватні ключі генеруються з одного шматка інформації на основі гаманця. Ця інформація дозволяє детерміновано та ієрархічно похідні пари дочірніх ключів. Ентропія є основою кожного HD гаманця, хоча не існує стандарту для генерації цього випадкового числа. Тому генерація випадкових чисел є великим викликом у забезпеченні безпеки транзакцій Bitcoin.

## Мнемонічна фраза
<chapterId>8f9340c1-e6dc-5557-a2f2-26c9669987d5</chapterId>

Безпека гаманця Bitcoin є великою турботою для всіх його користувачів. Один із суттєвих способів забезпечення резервного копіювання гаманця полягає у генерації мнемонічної фрази на основі ентропії та контрольної суми.

![зображення](assets/image/section3/5.webp)

Щоб перетворити ентропію на мнемонічну фразу, просто розрахуйте контрольну суму ентропії та об'єднайте ентропію та контрольну суму.

Після генерації ентропії використовується функція SHA256 на ентропії для створення хешу.
Вилучаються перші 8 біт хешу, які є контрольною сумою.
Мнемонічна фраза є результатом додавання ентропії до контрольної суми.

Контрольна сума забезпечує перевірку точності фрази відновлення. Без цієї контрольної суми помилка у фразі могла б призвести до створення іншого гаманця і, отже, до втрати коштів. Контрольна сума отримується шляхом проходження ентропії через функцію SHA256 і вилучення перших 8 біт хешу.

![зображення](assets/image/section3/6.webp)

Існують різні стандарти для мнемонічної фрази залежно від розміру ентропії. Найбільш поширений стандарт для фрази відновлення з 24 словами є ентропія 256 біт. Розмір контрольної суми визначається діленням розміру ентропії на 32.

Наприклад, ентропія 256 біт генерує 8-бітну контрольну суму. Об'єднання ентропії та контрольної суми потім призводить до відповідних розмірів 128 біт, 160 біт тощо. Залежно від розміру ентропії, фраза відновлення буде складатися з 12 слів для 128 біт, 15 слів для 160 біт і 24 слів для 256 біт.

**Кодування мнемонічної фрази:**

![зображення](assets/image/section3/7.webp)

Останні 8 біт відповідають контрольній сумі.
Кожен 11-бітний сегмент перетворюється в десяткове число.
Кожне десяткове число відповідає слову зі списку 2048 слів за BIP39. Важливо зазначити, що жодне слово не має однакового порядку перших чотирьох літер.

Життєво важливо зробити резервну копію 24-слівної фрази відновлення, щоб зберегти цілісність гаманця Bitcoin. Дві найбільш поширені стандарти базуються на ентропії 128 або 256 біт і об'єднанні 12 або 24 слів. Додавання парольної фрази є додатковою опцією для підвищення безпеки гаманця.

На завершення, генерація мнемонічної фрази для забезпечення безпеки гаманця Bitcoin є критично важливим процесом. Важливо дотримуватися стандартів мнемонічної фрази залежно від розміру ентропії. Резервне копіювання 24-слівної фрази відновлення є суттєвим для запобігання будь-якій втраті коштів.

## Парольна фраза
<chapterId>6a51b397-f3b5-5084-b151-cef94bc9b93f</chapterId>
Парольна фраза є додатковим паролем, який може бути інтегрований у Bitcoin гаманець для збільшення його безпеки. Її використання є необов'язковим і залишається на розсуд користувача. Додавання довільної інформації, яка разом з мнемонічною фразою дозволяє розрахувати seed гаманця, підвищує його безпеку.

![image](assets/image/section3/8.webp)

Парольна фраза є необов'язковою криптографічною "сіллю" розміру, обраного користувачем. Вона покращує безпеку HD гаманця, додаючи довільну інформацію, яка, будучи поєднаною з мнемонічною фразою, дозволить розрахувати seed.

Одного разу встановлена під час створення гаманця, вона необхідна для похідної всіх ключів гаманця. Функція pbkdf2 використовується для генерації seed з парольної фрази. Цей seed дозволяє похідну всіх дочірніх пар ключів гаманця. Якщо парольна фраза змінюється, Bitcoin гаманець стає абсолютно іншим.

Парольна фраза є важливим інструментом для підвищення безпеки Bitcoin гаманців. Вона може дозволити реалізацію різних стратегій безпеки. Наприклад, вона може бути використана для створення дублікатів і сприяти резервному копіюванню мнемонічної фрази. Вона також може покращити безпеку гаманця, зменшуючи ризики, пов'язані з випадковою генерацією мнемонічної фрази.

Ефективна парольна фраза повинна бути довгою (20 до 40 символів) і різноманітною (використовуючи великі літери, малі літери, цифри та символи). Вона не повинна бути прямо пов'язана з користувачем або його оточенням. Безпечніше використовувати випадкову послідовність символів, а не просте слово як парольну фразу.

![image](assets/image/section3/9.webp)

Парольна фраза є безпечнішою, ніж простий пароль. Ідеальна парольна фраза є довгою, різноманітною та випадковою. Вона може покращити безпеку гаманця або гарячого програмного забезпечення. Вона також може бути використана для створення надійних і безпечних резервних копій.

Дуже важливо піклуватися про резервні копії парольної фрази, щоб уникнути втрати доступу до гаманця. Парольна фраза є опцією для HD гаманця. Вона може бути згенерована випадково за допомогою костей або іншого псевдовипадкового генератора чисел. Не рекомендується запам'ятовувати парольну фразу або мнемонічну фразу.

У нашому наступному уроці ми детально розглянемо функціонування seed і першої пари ключів, згенерованої з нього. Не соромтеся слідувати за цим курсом, щоб продовжити навчання. Ми з нетерпінням чекаємо на зустріч з вами дуже скоро.

# Створення Bitcoin гаманців
<partId>9c25e767-7eae-50b8-8c5f-679d8fc83bab</partId>

## Створення Seed і Майстер-Ключа
<chapterId>63093760-2010-5691-8d0e-9a04732ae557</chapterId>

У цій частині курсу ми дослідимо кроки для похідної Ієрархічного Детермінованого Гаманця (HD Wallet), який дозволяє ієрархічне та детерміноване створення та управління приватними та публічними ключами.

![image](assets/image/section4/0.webp)

Основа HD Гаманця спирається на два основні елементи: мнемонічну фразу та парольну фразу (необов'язковий додатковий пароль). Разом вони становлять seed, алфавітно-цифрову послідовність 512 біт, яка служить основою для похідної ключів гаманця. З цього seed можливо похідну всі дочірні пари ключів Bitcoin гаманця. Seed є ключем, який надає доступ до всіх біткойнів, асоційованих з гаманцем, чи ви використовуєте парольну фразу, чи ні.

![image](assets/image/section4/1.webp)
Для отримання сіду використовується функція pbkdf2 (Password-Based Key Derivation Function 2) з мнемонічною фразою та парольною фразою. Результатом pbkdf2 є 512-бітний сід.
З сіду можна визначити майстер-приватний ключ та код ланцюга за допомогою алгоритму HMAC SHA-512 (Hash-based Message Authentication Code Secure Hash Algorithm 512). Цей алгоритм вимагає повідомлення та ключ як вхідні дані для генерації результату. Майстер-приватний ключ розраховується з сіду та фрази "Bitcoin SEED". Ця фраза є однаковою для всіх похідних всіх HD гаманців, забезпечуючи консистентність між гаманцями.

Спочатку функція SHA-512 не була реалізована в протоколі Bitcoin, тому використовується HMAC SHA-512. Використання HMAC SHA-512 з фразою "Bitcoin SEED" обмежує користувача генерацією гаманця, специфічного для Bitcoin. Результатом HMAC SHA-512 є 512-бітне число, поділене на дві частини: ліві 256 бітів представляють майстер-приватний ключ, тоді як праві 256 бітів представляють майстер-код ланцюга.

![image](assets/image/section4/2.webp)

Майстер-приватний ключ є батьківським ключем усіх майбутніх ключів у гаманці, тоді як майстер-код ланцюга бере участь у похідні дочірніх ключів. Важливо зауважити, що без знання відповідного коду ланцюга батьківської пари неможливо отримати пару дочірніх ключів.

Пара ключів у гаманці складається з приватного ключа, публічного ключа та коду ланцюга. Код ланцюга вносить джерело випадковості у похідні дочірніх ключів та ізолює кожну пару ключів, щоб запобігти будь-якому витоку інформації.
Важливо зауважити, що майстер-приватний ключ є першим приватним ключем, отриманим з сіду, і не має зв'язку з розширеними ключами гаманця.

У наступному уроці ми детально розглянемо розширені ключі, такі як xPub, xPRV, zPub, і зрозуміємо, чому вони використовуються та як вони будуються.

## Розширені ключі
<chapterId>8dcffce1-31bd-5e0b-965b-735f5f9e4602</chapterId>

У цій частині уроку ми вивчимо розширені ключі (xPub, zPub, yPub) та їх префікси, які відіграють важливу роль у похідні дочірніх ключів у Ієрархічному Детермінованому Гаманці (HD Wallet).

![image](assets/image/section4/3.webp)

Розширені ключі відрізняються від майстер-ключів. HD гаманець генерує мнемонічну фразу та сід для отримання майстер-ключа та майстер-коду ланцюга. Розширені ключі використовуються для похідних дочірніх ключів і вимагають як батьківський ключ, так і відповідний код ланцюга. Розширений ключ поєднує ці дві частини інформації для спрощення процесу похідних.

![image](assets/image/section4/4.webp)

Розширені публічні ключі можуть похідні лише звичайні дочірні публічні ключі, тоді як розширені приватні ключі можуть похідні як дочірні публічні, так і приватні ключі, як через звичайну, так і через ускладнену похідну. Ускладнена похідна відбувається від батьківського приватного ключа, тоді як звичайна похідна відповідає похідні від батьківського публічного ключа.

Використання розширених ключів з префіксом XPUB дозволяє похідні нові адреси без повернення до відповідних приватних ключів, таким чином забезпечуючи кращу безпеку. Метадані, пов'язані з розширеними ключами, надають важливу інформацію про їх роль та позицію в ієрархії ключів.
Розширені ключі ідентифікуються за допомогою специфічних префіксів (XPRV, XPUB, YPUB, ZPUB), які вказують, чи є це розширеним приватним або публічним ключем, а також їхнє конкретне призначення. Метадані, асоційовані з розширеним ключем, включають версію (префікс), глибину, відбиток батьківського ключа, індекс та вантаж (ланцюговий код та батьківський ключ).
![зображення](assets/image/section4/5.webp)

Версія відповідає типу ключа: xpub, xprv, ...

Глибина відповідає кількості похідних між батьківськими та дочірніми ключами з моменту створення майстер-ключа.

Відбиток батька - це перші 4 байти хешу 160 батьківського ключа.
Індекс - це номер пари, яка використовується для генерації розширеного ключа серед його однолітків. (однолітки = ключі тієї ж глибини) Наприклад, якщо ми хочемо отримати xpub нашого третього рахунку, його індекс буде 2 (тому що індекс починається з 0).

Вантаж складається з ланцюгового коду (32 байти) та батьківського ключа (33 байти).

Стиснені публічні ключі мають розмір 33 байти, тоді як сирі публічні ключі мають 512 біт. Стиснені публічні ключі зберігають ту саму інформацію, що й сирі ключі, але з меншим розміром. Розширені ключі мають розмір 82 байти, і їх префікс представлений у базі 58 через перетворення в шістнадцятковий формат. Контрольна сума розраховується за допомогою хеш-функції HASH256.

![зображення](assets/image/section4/6.webp)

Покращені похідні починаються з індексів, які є ступенями двійки (2^31). Цікаво, що найбільш часто використовувані префікси - це xpub та zpub, які відповідно відповідають стандартам спадщини та segwit v1 та segwit v0.

У нашому наступному уроці ми зосередимося на похідних дочірніх парах ключів, використовуючи знання, отримані про розширені ключі та майстер-ключ гаманця.

## Похідні дочірніх пар ключів
<chapterId>61c0807c-845b-5076-ad06-7f395b36adfd</chapterId>

Нагадуємо, ми обговорювали розрахунок зерна та майстер-ключа, які є першими основними елементами для ієрархічної організації та похідних HD (Ієрархічно Детермінованого) гаманця. Зерно, довжиною від 128 до 256 біт, генерується випадково або з секретної фрази. Воно відіграє детерміновану роль у похідних усіх інших ключів. Майстер-ключ - це перший ключ, похідний від зерна, і він дозволяє похідні всіх інших дочірніх пар ключів.

Майстер-ланцюговий код відіграє важливу роль у відновленні гаманця з зерна. Варто зазначити, що всі ключі, похідні від одного зерна, матимуть однаковий майстер-ланцюговий код.

![зображення](assets/image/section4/7.webp)

Ієрархічна організація та похідні HD гаманця пропонують більш ефективне управління ключами та структурами гаманця. Розширені ключі дозволяють похідні дочірньої пари ключів з батьківської пари за допомогою математичних розрахунків та специфічних алгоритмів.
Існують різні типи дочірніх пар ключів, включаючи посилені ключі та звичайні ключі. Розширений публічний ключ дозволяє лише похідні звичайних дочірніх публічних ключів, тоді як розширений приватний ключ дозволяє похідні всіх дочірніх ключів, як публічних, так і приватних, чи вони в звичайному, чи в посиленому режимі. Кожна пара ключів має індекс, який дозволяє їх розрізняти один від одного.

![зображення](assets/image/section4/8.webp)
Похідні дочірні ключі використовують функцію HMAC-SHA512, яка використовує батьківський ключ, об'єднаний з індексом та кодом ланцюга, асоційованим з парою ключів. Звичайні дочірні ключі мають індекс в діапазоні від 0 до 2 у ступені 31 мінус 1, тоді як посилені дочірні ключі мають індекс в діапазоні від 2 у ступені 31 до 2 у ступені 32 мінус 1.
![зображення](assets/image/section4/9.webp)

![зображення](assets/image/section4/10.webp)

Існують два типи пар дочірніх ключів: посилені пари та звичайні пари. Процес отримання дочірніх ключів використовує публічні ключі для генерації умов витрат, тоді як приватні ключі використовуються для підпису. Розширений публічний ключ дозволяє отримувати лише звичайні дочірні публічні ключі, тоді як розширений приватний ключ дозволяє отримувати всі дочірні ключі, як публічні, так і приватні, у звичайному або посиленому режимі.

![зображення](assets/image/section4/11.webp)
![зображення](assets/image/section4/12.webp)

Посилене отримання використовує приватний ключ батьків, тоді як звичайне отримання використовує публічний ключ батьків. Функція HMAC-SHA512 використовується для посиленого отримання, тоді як звичайне отримання використовує 512-бітний дайджест. Дочірній публічний ключ отримується шляхом множення дочірнього приватного ключа на генератор еліптичної кривої.

![зображення](assets/image/section4/13.webp)
![зображення](assets/image/section4/14.webp)

Ієрархічне отримання та детерміноване отримання багатьох пар ключів дозволяє створювати структуру дерева для ієрархічного отримання. У наступному уроці цього навчання ми вивчимо структуру HD гаманця, а також шляхи отримання, з особливим акцентом на нотації шляхів отримання.

## Структура гаманця та шляхи отримання
<chapterId>34e1bbda-67de-5493-b268-1fded8d67689</chapterId>

У цьому розділі ми вивчимо структуру дерева отримання в Ієрархічному Детермінованому Гаманці (HD Wallet). Ми вже дослідили розрахунок початкового значення, майстер-ключ та отримання пар дочірніх ключів. Тепер ми зосередимося на організації ключів у гаманці.

HD Гаманець використовує шари глибини для організації ключів. Кожне отримання від батьківської пари до дочірньої пари відповідає шару глибини.

![зображення](assets/image/section4/15.webp)

- Глибина 0 відповідає майстер-ключу та майстер-коду ланцюга.

- Глибина 1 використовується для отримання дочірніх ключів для конкретної мети, визначеної індексом. Мети відповідають стандартам BIP 84 та Segwit v0/v1.

- Глибина 2 дозволяє розрізняти рахунки для різних криптовалют або мереж. Це дозволяє організовувати гаманець на основі різних джерел коштів. Для біткойна індекс буде 0.

- Глибина 3 використовується для організації гаманця на різні рахунки, забезпечуючи більш чітку та організовану структуру.

- Глибина 4 відповідає зовнішнім та внутрішнім ланцюгам, які використовуються для адрес, призначених для публічного спілкування. Індекс 0 асоційований з зовнішнім ланцюгом, тоді як індекс 1 асоційований з внутрішнім ланцюгом. Кожен рахунок має два ланцюги: зовнішній ланцюг (0) та внутрішній ланцюг (1). Глибина 4 також використовується для управління типами скриптів у випадку гаманців з мультипідписом.

- Глибина 5 використовується для отримувальних адрес у стандартному гаманці. У наступному розділі ми детальніше розглянемо отримання пар дочірніх ключів.

![зображення](assets/image/section4/16.webp)

Для кожного шару глибини ми використовуємо індекси для розрізнення пар дочірніх ключів.
Індекс без апострофа відповідає фактично використаному індексу, тоді як індекс з апострофом відповідає фактичному індексу + 2^31. Закріплені похідні використовують індекси від 2^31 до 2^32-1. Наприклад, індекс 44' відповідає фактичному індексу 2^31 + 44.
Для генерації конкретної адреси отримувача ми виводимо дочірню пару ключів з майстер-ключа та майстер-коду ланцюга. Потім ми використовуємо індекс для розрізнення між різними дочірніми парами ключів на однаковій глибині.

Розширені ключі, такі як XPUB, дозволяють вам ділитися своїм гаманцем з кількома людьми. Шлях похідної використовується для розрізнення між зовнішнім ланцюгом (адреси, призначені для спільного використання) та внутрішнім ланцюгом (адреси для здачі).

У наступному розділі ми вивчимо адреси отримувачів, їх переваги використання та етапи їх створення.

# Що таке Bitcoin адреса?
<partId>81ec8d17-f8ee-5aeb-8035-d370866f4281</partId>

## Bitcoin адреси
<chapterId>0a887ed8-3424-5a52-98e1-e4b406150475</chapterId>

У цьому розділі ми дослідимо адреси отримувачів, які відіграють важливу роль у системі Bitcoin. Вони дозволяють отримувати кошти в транзакції та генеруються з пар приватних і публічних ключів. Хоча існує тип скрипта під назвою Pay2PublicKey, який дозволяє блокувати біткоїни на публічному ключі, користувачі зазвичай віддають перевагу використанню адрес отримувачів замість цього скрипта.

![image](assets/image/section5/0.webp)

Коли одержувач хоче отримати біткоїни, він надає адресу отримувача відправнику замість свого публічного ключа. Адреса насправді є хешем публічного ключа з певним форматом. Публічний ключ виводиться з дочірнього приватного ключа за допомогою математичних операцій, таких як додавання точок і подвоєння на еліптичних кривих.

![image](assets/image/section5/1.webp)

Важливо зазначити, що неможливо здійснити зворотний перехід від адреси до публічного ключа, ані від публічного ключа до приватного ключа. Використання адреси зменшує розмір інформації публічного ключа, яка спочатку становить 512 біт.

Розмір Bitcoin адрес було зменшено для полегшення їх використання. Вони мають контрольну суму, яка дозволяє виявляти помилки при введенні та зменшує ризик втрати біткоїнів. З іншого боку, публічні ключі не мають контрольної суми, що означає, що помилки можуть призвести до втрати відповідних коштів.

Адреси також забезпечують другий рівень безпеки між публічною та приватною інформацією, роблячи контроль над приватним ключем складнішим.

Важливо підкреслити, що кожну адресу слід використовувати лише один раз. Повторне використання тієї ж адреси створює проблеми з конфіденційністю і слід уникати.

Для Bitcoin адрес використовуються різні префікси. Наприклад, BC1Q відповідає адресі Segwit V0, BC1P - адресі Taproot/Segwit V1, а префікси 1 та 3 асоціюються з Pay2PublicKeyH/Pay2ScriptH (спадковими) адресами. У наступному уроці ми пояснимо крок за кроком, як вивести адресу з публічного ключа.

## Як створити Bitcoin адресу?
<chapterId>6dee7bf3-7767-5f8d-a01b-659b95cfe0a5</chapterId>

У цьому розділі ми обговоримо створення адреси отримувача для Bitcoin транзакцій. Адреса отримувача є буквено-цифровим представленням стислого публічного ключа. Перетворення публічного ключа в адресу отримувача включає кілька кроків.

### Крок 1: Стиснення публічного ключа
![зображення](assets/image/section5/14.webp)
Адреса походить від дочірнього публічного ключа.

Публічний ключ - це точка на еліптичній кривій. Завдяки симетрії еліптичної кривої, точка на еліптичній кривій матиме координату x, асоційовану лише з двома можливими значеннями для y: позитивним або негативним.
Однак, у протоколі Bitcoin ми працюємо з кінцевим набором позитивних цілих чисел, а не з набором дійсних чисел. Для розрізнення двох можливих значень y достатньо вказати, чи є y парним або непарним.

Компресія публічного ключа зменшує його розмір з 520 біт до 264 біт.

Ми використовуємо префікс 0x02 для парного y та 0x03 для непарного y. Це є стислою формою публічного ключа.

### Крок 2: Хешування стислого публічного ключа

![зображення](assets/image/section5/3.webp)

Хешування стислого публічного ключа виконується за допомогою функції SHA256. Потім застосовується функція RIPEMD160 до дайджесту.

### Крок 3: Поле даних = Адресний поле даних

![зображення](assets/image/section5/4.webp)

Бінарний дайджест RIPEMD160(SHA256(K)) використовується для формування груп по 5 біт. Кожна група перетворюється в базу 16 (Шістнадцяткову) та/або базу 10.

### Крок 4: Додавання метаданих для розрахунку контрольної суми за допомогою програми BCH

![зображення](assets/image/section5/5.webp)

У випадку зі старими адресами ми використовуємо подвійне хешування SHA256 для генерації контрольної суми адреси. Однак, для адрес Segwit V0 та V1, ми покладаємося на технологію контрольної суми BCH для забезпечення виявлення помилок. Програма BCH здатна пропонувати та виправляти помилки з надзвичайно низькою ймовірністю помилки. Наразі програма BCH використовується для виявлення та пропонування змін, але вона не виконує їх автоматично від імені користувача.

Програма BCH вимагає кілька вхідних даних, включаючи HRP (Human Readable Part), який потрібно розширити. Розширення HRP включає кодування кожної літери в базі 2 відповідно до їх ASCII коду. Потім, взявши перші 3 біти результату для кожної літери та перетворивши їх в базу 10 (на зображенні синім). Вставте роздільник 0. Потім конкатенуйте наступні 5 біт кожної літери, раніше перетвореної в базу 10 (на зображенні жовтим).

Розширення HRP в базі 10 дозволяє ізолювати останні п'ять біт кожного символу, таким чином посилюючи контрольну суму.

Версія Segwit V0 представлена кодом 00, а "поле даних" чорним, в базі 10. За цим слідує шість зарезервованих символів для контрольної суми.

### Крок 5: Розрахунок контрольної суми за допомогою програми BCH

![зображення](assets/image/section5/6.webp)

Вхідні дані, що містять метадані, потім подаються до програми BCH для отримання контрольної суми в базі 10.

Ось ми маємо контрольну суму.

### Крок 6: Конструкція адреси та перетворення в Bech32

![зображення](assets/image/section5/7.webp)

Конкатенація версії, поля даних та контрольної суми дозволяє побудувати адресу. Символи бази 10 потім перетворюються в символи Bech32 за допомогою таблиці відповідностей. Алфавіт Bech32 включає всі алфавітно-цифрові символи, крім 1, b, i та o, щоб уникнути будь-якої плутанини.

### Крок 7: Додавання HRP та роздільника

![зображення](assets/image/section5/8.webp)

На зображенні рожевим - контрольна сума.
У чорному, вантаж = хеш публічного ключа. У синьому, версія.

Все перетворюється на Bech32, потім додається 'bc' для біткоїна та '1' як роздільник, і ось адреса.

# Далі
<partId>58111408-b734-54db-9ea7-0d5b67f99f99</partId>

## Створення seed з 128 кидків костей!
<chapterId>0f4d40a7-cf0e-5faf-bc4d-691486771ac1</chapterId>

Створення мнемонічної фрази є критично важливим кроком у захисті вашого криптовалютного гаманця. Існує кілька методів генерації мнемонічної фрази, однак ми зосередимося на ручному методі генерації за допомогою костей. Важливо зазначити, що цей метод не підходить для гаманця з великою вартістю. Рекомендується використовувати відкритий програмний забезпечення або апаратний гаманець для генерації мнемонічної фрази. Для створення мнемонічної фрази ми будемо використовувати кості для генерації бінарної інформації. Мета полягає в тому, щоб зрозуміти процес створення мнемонічної фрази.

**Крок 1 - Підготовка:**
Переконайтеся, що у вас є амнезійна дистрибуція Linux, така як Tails OS, встановлена на USB-ключі для додаткової безпеки. Зверніть увагу, що цей навчальний посібник не слід використовувати для створення основного гаманця.
**Крок 2 - Генерація випадкового бінарного числа:**
Ми будемо використовувати кості для генерації бінарної інформації. Кидайте кість 128 разів і записуйте кожен результат (1 для непарного, 0 для парного).

**Крок 3 - Організація бінарних чисел:**
Організуйте отримані бінарні числа у рядки по 11 цифр для полегшення подальших розрахунків. Дванадцятий рядок повинен містити лише 7 цифр.

**Крок 4 - Розрахунок контрольної суми:**
Останні 4 цифри для дванадцятого рядка відповідають контрольній сумі. Для розрахунку цієї контрольної суми нам потрібно використовувати термінал з дистрибуції Linux. Рекомендується використовувати [TailOs](https://tails.boum.org/index.fr.html), який є завантажуваною безпам'ятною дистрибуцією з USB-ключа. Одного разу на вашому терміналі введіть команду `echo <бінарне число> | shasum -a 254 -0`. Замініть `<бінарне число>` на ваш список з 128 нулів та одиниць. Вихідними даними буде шістнадцятковий хеш. Запишіть перший символ цього хешу та перетворіть його на бінарний. Ви можете використовувати цю [таблицю](https://www.educative.io/answers/decimal-binary-and-hex-conversion-table) для допомоги. Додайте бінарну контрольну суму (4 цифри) до дванадцятого рядка вашого аркуша.

**Крок 5 - Перетворення в десяткове:**
Щоб знайти слова, асоційовані з кожним з ваших рядків, спочатку вам потрібно перетворити кожну серію з 11 бітів у десяткове число. Тут ви не можете використовувати онлайн-конвертер, оскільки ці біти представляють вашу мнемонічну фразу. Тому вам потрібно буде перетворити, використовуючи калькулятор та хитрість наступним чином: кожен біт асоційований зі ступенем 2, тож зліва направо ми маємо 11 рангів, що відповідають 1024, 512, 256, 128, 64, 32, 16, 8, 4, 2, 1. Щоб перетворити вашу серію з 11 бітів у десяткове число, просто додайте лише ті ранги, які містять 1. Наприклад, для серії 00110111011, це відповідає наступному додаванню: 256 + 128 + 32 + 16 + 8 + 2 + 1 = 443. Тепер ви можете перетворити кожен рядок у десяткове число. І перед тим, як перейти до кодування у слова, додайте +1 до всіх рядків, оскільки індекс списку слів BIP39 починається з 1, а не з 0.
**Крок 8 - Генерація мнемонічної фрази:**
Почніть з друку [списку з 2048 слів](https://seedxor.com/files/wordlist.pdf), щоб конвертувати між вашими десятковими числами та словами BIP39. Унікальність цього списку полягає в тому, що жодне слово не ділить перші 4 літери з будь-яким іншим словом у цьому словнику. Потім шукайте слово, асоційоване з десятковим числом кожного з ваших рядків.
**Крок 9 - Тест мнемонічної фрази:**
Негайно перевірте вашу мнемонічну фразу в Sparrow Wallet, створивши гаманець з неї. Якщо ви отримаєте помилку недійсної контрольної суми, ймовірно, ви зробили помилку в розрахунках. Виправте цю помилку, повернувшись до кроку 4 і знову протестуйте на Sparrow Wallet. Вуаля! Ви щойно створили новий Bitcoin гаманець з 128 кидків костей.

Генерація мнемонічної фрази є важливим процесом для забезпечення безпеки вашого криптовалютного гаманця. Рекомендується використовувати більш безпечні методи, такі як використання відкритого програмного забезпечення або апаратного гаманця, для генерації мнемонічної фрази. Однак, завершення цього майстер-класу допомагає краще зрозуміти, як ми можемо створити Bitcoin гаманець з випадкового числа.

## БОНУС: Інтерв'ю з Тео Пантамісом
<chapterId>39f0ec5a-e258-55cb-9789-bc46d314d816</chapterId>

Ще один широко використовуваний криптографічний метод у протоколі Bitcoin - це метод цифрових підписів.

![відео](https://youtu.be/c9MvtGJsEvY?si=bQ1N5NCd6op0G6nW)

## Дайте нам зворотний зв'язок про цей курс
<chapterId>0cd71541-a7fd-53db-b66a-8611b6a28b04</chapterId>
<isCourseReview>true</isCourseReview>

## Висновок і закінчення
<chapterId>d291428b-3cfa-5394-930e-4b514be82d5a</chapterId>

### Дякуємо та продовжуйте досліджувати кролячу нору

Ми щиро дякуємо вам за завершення курсу Crypto 301. Ми сподіваємося, що цей досвід був для вас збагачуючим і освітнім. Ми розглянули багато захоплюючих тем, від математики до криптографії до роботи протоколу Bitcoin.

Якщо ви хочете глибше зануритися в тему, ми маємо для вас додатковий ресурс. Ми провели ексклюзивне інтерв'ю з Тео Пантамісом та Лоїком Морелем, двома відомими експертами у галузі криптографії. Це інтерв'ю досліджує різні аспекти предмету більш глибоко і надає цікаві перспективи.
Не соромтеся переглянути це інтерв'ю, щоб продовжити дослідження захоплюючої галузі криптографії. Ми сподіваємося, що воно буде корисним та надихаючим у вашому подорожі. Ще раз дякуємо за вашу участь та відданість протягом цього курсу.
### Підтримайте нас

Цей курс, разом з усім контентом на цьому університеті, був наданий вам безкоштовно нашою спільнотою. Щоб підтримати нас, ви можете поділитися ним з іншими, стати членом університету, а навіть зробити внесок у його розвиток через GitHub. Від імені всієї команди, дякуємо!

### Оцініть курс

Система оцінювання для навчання незабаром буде інтегрована в цю нову платформу E-learning! Тим часом, дуже дякуємо, що пройшли курс, і якщо він вам сподобався, будь ласка, розгляньте можливість поділитися ним з іншими.